// Copyright 2022 Lekko Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package gen

import (
	"bytes"
	"context"
	"fmt"
	"go/format"
	"io/fs"
	"os"
	"os/exec"
	"path"
	"path/filepath"
	"regexp"
	"slices"
	"sort"
	"strconv"
	"strings"
	"text/template"

	featurev1beta1 "buf.build/gen/go/lekkodev/cli/protocolbuffers/go/lekko/feature/v1beta1"
	rulesv1beta3 "buf.build/gen/go/lekkodev/cli/protocolbuffers/go/lekko/rules/v1beta3"
	"github.com/iancoleman/strcase"
	"github.com/lainio/err2/assert"
	"github.com/lainio/err2/try"
	"github.com/lekkodev/cli/pkg/repo"
	"github.com/lekkodev/cli/pkg/secrets"
	"github.com/pkg/errors"
	"github.com/spf13/cobra"
	"golang.org/x/mod/modfile"
	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/reflect/protoregistry"
	"google.golang.org/protobuf/types/known/anypb"
	"google.golang.org/protobuf/types/known/structpb"
	"google.golang.org/protobuf/types/known/wrapperspb"
)

var typeRegistry *protoregistry.Types

const defaultOutputPath = "internal/lekko"

// TODO make this work for GO
func structpbValueToKindStringGo(v *structpb.Value) string {
	switch v.GetKind().(type) {
	case *structpb.Value_NumberValue:
		// TODO: figure out how to handle this ambiguity better
		return "float64"
	case *structpb.Value_BoolValue:
		return "bool"
	case *structpb.Value_StringValue:
		return "string"
	}
	return "unknown" // do we just want to panic?
}

func GenGoCmd() *cobra.Command {
	var ns string
	var wd string
	cmd := &cobra.Command{
		Use:   "go",
		Short: "generate Go library code from configs",
		RunE: func(cmd *cobra.Command, args []string) error {
			b, err := os.ReadFile("go.mod")
			if err != nil {
				return err
			}
			mf, err := modfile.ParseLax("go.mod", b, nil)
			if err != nil {
				return err
			}
			moduleRoot := mf.Module.Mod.Path

			rs := secrets.NewSecretsOrFail()
			r, err := repo.NewLocal(wd, rs)
			if err != nil {
				return errors.Wrap(err, "new repo")
			}
			rootMD, nsMDs := try.To2(r.ParseMetadata(cmd.Context()))
			// TODO this feels weird and there is a global set we should be able to add to but I'll worrry about it later?
			typeRegistry = try.To1(r.BuildDynamicTypeRegistry(cmd.Context(), rootMD.ProtoDirectory))
			staticCtxType := UnpackProtoType(moduleRoot, nsMDs[ns].ContextProto)
			ffs, err := r.GetFeatureFiles(cmd.Context(), ns)
			if err != nil {
				return err
			}
			// Sort configs in alphabetical order
			sort.SliceStable(ffs, func(i, j int) bool {
				return ffs[i].CompiledProtoBinFileName < ffs[j].CompiledProtoBinFileName
			})

			var publicFuncStrings []string
			var privateFuncStrings []string
			protoImportSet := make(map[string]*ProtoImport)
			addStringsImport := false
			addSlicesImport := false
			if staticCtxType != nil {
				protoImportSet[staticCtxType.ImportPath] = staticCtxType
			}
			for _, ff := range ffs {
				fff, err := os.ReadFile(path.Join(wd, ns, ff.CompiledProtoBinFileName))
				if err != nil {
					return err
				}
				f := &featurev1beta1.Feature{}
				if err := proto.Unmarshal(fff, f); err != nil {
					return err
				}
				generated := try.To1(genGoForFeature(cmd.Context(), r, f, ns, staticCtxType))
				publicFuncStrings = append(publicFuncStrings, generated.public)
				privateFuncStrings = append(privateFuncStrings, generated.private)
				if generated.usedStrings {
					addStringsImport = true
				}
				if generated.usedSlices {
					addSlicesImport = true
				}
				if f.Type == featurev1beta1.FeatureType_FEATURE_TYPE_PROTO {
					protoImport := UnpackProtoType(moduleRoot, f.Tree.Default.TypeUrl)
					protoImportSet[protoImport.ImportPath] = protoImport
				}
			}
			// For each namespace, we want to generate under lekko/:
			// lekko/
			//   <namespace>/
			//     lekko.go
			//     lekko_gen.go

			// lekko.go (maybe should use namespace name?) is meant to be edited by the user, contains private native lang funcs
			// lekko_gen.go is marked as machine-generated, contains public funcs to be used in application code

			const publicFileTemplateBody = `// Generated by Lekko. DO NOT EDIT.
package lekko{{$.Namespace}}

import (
	"context"
{{range $.ProtoImports}}
	{{ . }}{{end}}
	client "github.com/lekkodev/go-sdk/client"
)

type LekkoClient struct {
	client.Client
}

{{range $.PublicFuncStrings}}
{{ . }}{{end}}`

			// TODOs for the template:
			// - make sure to test if slices is valid depending on go versions
			// - add go generate directive to invoke this command
			//   - but if doing 2-way and directive already exists, should respect original
			const privateFileTemplateBody = `package lekko{{$.Namespace}}

import (
	{{if $.AddStringsImport}}"strings"{{end}}
{{range $.ProtoImports}}
	{{ . }}{{end}}
	{{if $.AddSlicesImport}}"golang.org/x/exp/slices"{{end}}
)

{{range $.PrivateFuncStrings}}
{{ . }}{{end}}`

			// buf generate --template '{"version":"v1","plugins":[{"plugin":"go","out":"gen/go"}]}'
			//
			// This generates the code for the config repo, assuming it has a buf.gen.yml in that repo.
			// In OUR repos, and maybe some of our customers, they may already have a buf.gen.yml, so if
			// that is the case, we should identify that, not run code gen (maybe?) and instead need to
			// take the prefix by parsing the buf.gen.yml to understand where the go code goes.
			pCmd := exec.Command(
				"buf",
				"generate",
				// TODO: Fix the hardcoded stuff
				fmt.Sprintf(`--template={"managed": {"enabled": true, "go_package_prefix": {"default": "%s/%s/proto"}}, "version":"v1","plugins":[{"plugin":"go","out":"%s/proto", "opt": "paths=source_relative"}]}`, moduleRoot, defaultOutputPath, defaultOutputPath),
				"--include-imports",
				wd) // #nosec G204
			pCmd.Dir = "."
			fmt.Println("executing in wd: " + wd + " command: " + pCmd.String())
			if out, err := pCmd.CombinedOutput(); err != nil {
				fmt.Printf("Error when generating code with buf: %s\n %e\n", out, err)
				return err
			}
			// TODO: Fix hardcoded paths
			if err := os.MkdirAll(path.Join(defaultOutputPath, ns), 0770); err != nil {
				return err
			}
			var protoImports []string
			for _, imp := range protoImportSet {
				protoImports = append(protoImports, fmt.Sprintf(`%s "%s"`, imp.PackageAlias, imp.ImportPath))
			}
			data := struct {
				ProtoImports       []string
				Namespace          string
				PublicFuncStrings  []string
				PrivateFuncStrings []string
				AddStringsImport   bool
				AddSlicesImport    bool
			}{
				protoImports,
				ns,
				publicFuncStrings,
				privateFuncStrings,
				addStringsImport,
				addSlicesImport,
			}
			outputs := []struct {
				templateBody string
				fileName     string
			}{
				{
					templateBody: publicFileTemplateBody,
					fileName:     "lekko_gen.go",
				},
				{
					templateBody: privateFileTemplateBody,
					fileName:     "lekko.go",
				},
			}
			for _, output := range outputs {
				var contents bytes.Buffer
				templ := template.Must(template.New(output.fileName).Parse(output.templateBody))
				if err := templ.Execute(&contents, data); err != nil {
					return errors.Wrap(err, fmt.Sprintf("%s template", output.fileName))
				}
				// Final canonical Go format
				formatted, err := format.Source(contents.Bytes())
				if err != nil {
					return errors.Wrap(err, fmt.Sprintf("format %s", output.fileName))
				}
				if f, err := os.Create(path.Join(defaultOutputPath, ns, output.fileName)); err != nil {
					return err
				} else {
					if _, err := f.Write(formatted); err != nil {
						return errors.Wrap(err, fmt.Sprintf("write formatted contents to %s", f.Name()))
					}
				}
			}

			// Under lekko/, we also generate
			// lekko/
			//   client_gen.go <--
			//   <namespace>/
			//     ...

			// This is the "entrypoint" shared client initialization code that can be imported by the user
			// and allows access to all namespaces
			return genClientFile(moduleRoot)
		},
	}
	cmd.Flags().StringVarP(&ns, "namespace", "n", "default", "namespace to generate code from")
	cmd.Flags().StringVarP(&wd, "config-path", "c", ".", "path to configuration repository")
	return cmd
}

type generatedConfigCode struct {
	// "Generated" code, public interface for consumption
	public string
	// For user creation/editing
	private string
	// Whether the std package "strings" was used
	usedStrings bool
	// Whether the std package "slices" was used
	usedSlices bool
}

type configCodeTemplate struct {
	public  string
	private string
}

// Template body for primitive config code
func getDefaultTemplateBody() *configCodeTemplate {
	return &configCodeTemplate{
		public: `// {{$.Description}}
func (c *LekkoClient) {{$.FuncName}}({{$.ArgumentString}}) {{$.RetType}} {
  	{{ $.CtxStuff }}
  	result, err := c.{{$.GetFunction}}(ctx, "{{$.Namespace}}", "{{$.Key}}")
	if err == nil {
	  	return result
  	}
  	return {{$.PrivateFunc}}({{$.CallString}})
}`,
		private: `// {{$.Description}}
func {{$.PrivateFunc}}({{$.ArgumentString}}) {{$.RetType}} {
{{range  $.NaturalLanguage}}{{ . }}
{{end}}}`,
	}
}

// Template body for proto config code
func getProtoTemplateBody() *configCodeTemplate {
	return &configCodeTemplate{
		public: `// {{$.Description}}
func (c *LekkoClient) {{$.FuncName}}({{$.ArgumentString}}) *{{$.RetType}} {
		{{ $.CtxStuff }}
	result := &{{$.RetType}}{}
	err := c.{{$.GetFunction}}(ctx, "{{$.Namespace}}", "{{$.Key}}", result)
	if err == nil {
			return result
		}
		return {{$.PrivateFunc}}({{$.CallString}})
}`,
		private: `// {{$.Description}}
func {{$.PrivateFunc}}({{$.ArgumentString}}) *{{$.RetType}} {
{{range  $.NaturalLanguage}}{{ . }}
{{end}}}`,
	}
}

// Template body for configs that are top-level enums
// TODO: This isn't actually supported, figure this out as well
// Includes const declarations for the enums
func getStringEnumTemplateBody() *configCodeTemplate {
	return &configCodeTemplate{
		public: `type {{$.EnumTypeName}} string
const (
	{{range $index, $field := $.EnumFields}}{{$field.Name}} {{$.EnumTypeName}} = "{{$field.Value}}"
	{{end}}
)

// {{$.Description}}
func (c *LekkoClient) {{$.FuncName}}({{$.ArgumentString}}) {{$.RetType}} {
		{{ $.CtxStuff }}
		result, err := c.{{$.GetFunction}}(ctx, "{{$.Namespace}}", "{{$.Key}}")
	if err == nil {
			return result
		}
		return {{$.PrivateFunc}}({{$.CallString}})
}`,
		private: `type {{$.EnumTypeName}} string
const (
	{{range $index, $field := $.EnumFields}}{{$field.Name}} {{$.EnumTypeName}} = "{{$field.Value}}"
	{{end}}
)

// {{$.Description}}
func {{$.PrivateFunc}}({{$.ArgumentString}}) {{$.RetType}} {
{{range  $.NaturalLanguage}}{{ . }}
{{end}}}`,
	}
}

func genGoForFeature(ctx context.Context, r repo.ConfigurationRepository, f *featurev1beta1.Feature, ns string, staticCtxType *ProtoImport) (*generatedConfigCode, error) {
	var funcNameBuilder strings.Builder
	funcNameBuilder.WriteString("Get")
	for _, word := range regexp.MustCompile("[_-]+").Split(f.Key, -1) {
		funcNameBuilder.WriteString(strings.ToUpper(word[:1]) + word[1:])
	}
	funcName := funcNameBuilder.String()
	privateFunc := strcase.ToLowerCamel(funcName)
	var retType string
	var getFunction string
	var enumTypeName string
	type EnumField struct {
		Name  string
		Value string
	}
	var enumFields []EnumField
	templateBody := getDefaultTemplateBody()

	var protoType *ProtoImport
	switch f.Type {
	case featurev1beta1.FeatureType_FEATURE_TYPE_BOOL:
		retType = "bool"
		getFunction = "GetBool"
	case featurev1beta1.FeatureType_FEATURE_TYPE_INT:
		retType = "int64"
		getFunction = "GetInt"
	case featurev1beta1.FeatureType_FEATURE_TYPE_FLOAT:
		retType = "float64"
		getFunction = "GetFloat"
	case featurev1beta1.FeatureType_FEATURE_TYPE_STRING:
		retType = "string"
		getFunction = "GetString"
		// HACK: The metadata field is only for presentation at the moment
		// so is not part of the compiled object - need to statically parse
		// This also means that this only works for statically parseable
		// configs
		sf, err := r.Parse(ctx, ns, f.Key, typeRegistry)
		if err != nil {
			return nil, errors.Wrap(err, "static parsing")
		}
		fm := sf.Feature.Metadata.AsMap()
		// TODO: This enum codegen does not handle possible conflicts at all
		if genEnum, ok := fm["gen-enum"]; ok {
			if genEnumBool, ok := genEnum.(bool); ok && genEnumBool {
				enumTypeName = strcase.ToCamel(f.Key)
				retType = enumTypeName
				templateBody = getStringEnumTemplateBody()
				for _, ret := range getStringRetValues(f) {
					// Result of translating ret values is wrapped in quotes
					ret = ret[1 : len(ret)-1]
					name := enumTypeName
					if ret == "" {
						name += "Unspecified"
					} else {
						name += strcase.ToCamel(ret)
					}
					enumFields = append(enumFields, EnumField{
						Name:  name,
						Value: ret,
					})
				}
			}
		}
	case featurev1beta1.FeatureType_FEATURE_TYPE_JSON:
		// TODO: Actually figure out how we want to do json configs
		return nil, fmt.Errorf("unsupported json config %s/%s", ns, f.Key)
	case featurev1beta1.FeatureType_FEATURE_TYPE_PROTO:
		getFunction = "GetProto"
		templateBody = getProtoTemplateBody()
		// we don't need the import path so sending in empty string
		protoType = UnpackProtoType("", f.Tree.Default.TypeUrl)
		// creates configv1beta1.DBConfig
		retType = fmt.Sprintf("%s.%s", protoType.PackageAlias, protoType.Type)
	}

	data := struct {
		Description     string
		FuncName        string
		PrivateFunc     string
		GetFunction     string
		RetType         string
		Namespace       string
		Key             string
		NaturalLanguage []string
		ArgumentString  string
		CallString      string
		EnumTypeName    string
		EnumFields      []EnumField
		CtxStuff        string
	}{
		f.Description,
		funcName,
		privateFunc,
		getFunction,
		retType,
		ns,
		f.Key,
		[]string{},
		"",
		"",
		enumTypeName,
		enumFields,
		"",
	}
	generated := &generatedConfigCode{}
	usedVariables := make(map[string]string)
	if staticCtxType != nil {
		data.NaturalLanguage = translateFeature(f, protoType, true, usedVariables, &generated.usedStrings, &generated.usedSlices)
		data.ArgumentString = fmt.Sprintf("ctx *%s.%s", staticCtxType.PackageAlias, staticCtxType.Type)
		data.CallString = "ctx"
	} else {
		data.CtxStuff = "ctx := context.Background()\n"
		data.NaturalLanguage = translateFeature(f, protoType, false, usedVariables, &generated.usedStrings, &generated.usedSlices)
		var arguments []string
		var ctxAddLines []string
		for f, t := range usedVariables {
			arguments = append(arguments, fmt.Sprintf("%s %s", strcase.ToLowerCamel(f), t))
			ctxAddLines = append(ctxAddLines, fmt.Sprintf("ctx = client.Add(ctx, \"%s\", %s)", f, strcase.ToLowerCamel(f)))
		}
		// TODO: Sorting by name might not be the best solution for long-term UX... but it's simple and it works for now
		slices.Sort(arguments)
		slices.Sort(ctxAddLines)
		data.ArgumentString = strings.Join(arguments, ", ")
		data.CtxStuff += strings.Join(ctxAddLines, "\n")
		var keys []string
		for f := range usedVariables {
			keys = append(keys, strcase.ToLowerCamel(f))
		}
		slices.Sort(keys)
		data.CallString = strings.Join(keys, ", ")
	}
	if templ, err := template.New("public func").Parse(templateBody.public); err != nil {
		return nil, err
	} else {
		var ret bytes.Buffer
		if err := templ.Execute(&ret, data); err != nil {
			return nil, err
		}
		generated.public = ret.String()
	}
	if templ, err := template.New("private func").Parse(templateBody.private); err != nil {
		return nil, err
	} else {
		var ret bytes.Buffer
		if err := templ.Execute(&ret, data); err != nil {
			return nil, err
		}
		generated.private = ret.String()
	}
	return generated, nil
}

func translateFeature(f *featurev1beta1.Feature, protoType *ProtoImport, staticContext bool, usedVariables map[string]string, usedStrings, usedSlices *bool) []string {
	var buffer []string
	for i, constraint := range f.Tree.Constraints {
		ifToken := "} else if"
		if i == 0 {
			ifToken = "if"
		}
		rule := translateRule(constraint.GetRuleAstNew(), staticContext, usedVariables, usedStrings, usedSlices)
		buffer = append(buffer, fmt.Sprintf("\t%s %s {", ifToken, rule))

		// TODO this doesn't work for proto, but let's try
		buffer = append(buffer, fmt.Sprintf("\t\treturn %s", translateAnyValue(constraint.Value, protoType)))
	}
	if len(f.Tree.Constraints) > 0 {
		buffer = append(buffer, "\t}")
	}
	buffer = append(buffer, fmt.Sprintf("\treturn %s", translateAnyValue(f.GetTree().GetDefault(), protoType)))
	return buffer
}

// If one key is used in the context of more than one type, we should fail
func tryStoreUsedVariable(usedVariables map[string]string, k string, t string) {
	existT, ok := usedVariables[k]
	if !ok {
		usedVariables[k] = t
		return
	}
	// TODO: test with err2 handlers to handle more gracefully
	assert.Equal(t, existT)
}

func translateRule(rule *rulesv1beta3.Rule, staticContext bool, usedVariables map[string]string, usedStrings, usedSlices *bool) string {
	if rule == nil {
		return ""
	}
	// TODO: Do we actually want to case context keys in terms of cross language?
	switch v := rule.GetRule().(type) {
	case *rulesv1beta3.Rule_Atom:
		switch v.Atom.GetComparisonOperator() {
		case rulesv1beta3.ComparisonOperator_COMPARISON_OPERATOR_EQUALS:
			tryStoreUsedVariable(usedVariables, v.Atom.ContextKey, structpbValueToKindStringGo(v.Atom.ComparisonValue))
			if staticContext {
				return fmt.Sprintf("ctx.%s == %s", strcase.ToCamel(v.Atom.ContextKey), string(try.To1(protojson.Marshal(v.Atom.ComparisonValue))))
			} else {
				return fmt.Sprintf("%s == %s", strcase.ToLowerCamel(v.Atom.ContextKey), string(try.To1(protojson.Marshal(v.Atom.ComparisonValue))))
			}
		case rulesv1beta3.ComparisonOperator_COMPARISON_OPERATOR_NOT_EQUALS:
			tryStoreUsedVariable(usedVariables, v.Atom.ContextKey, structpbValueToKindStringGo(v.Atom.ComparisonValue))
			if staticContext {
				return fmt.Sprintf("ctx.%s != %s", strcase.ToCamel(v.Atom.ContextKey), string(try.To1(protojson.Marshal(v.Atom.ComparisonValue))))
			} else {
				return fmt.Sprintf("%s != %s", strcase.ToLowerCamel(v.Atom.ContextKey), string(try.To1(protojson.Marshal(v.Atom.ComparisonValue))))
			}
		case rulesv1beta3.ComparisonOperator_COMPARISON_OPERATOR_LESS_THAN:
			tryStoreUsedVariable(usedVariables, v.Atom.ContextKey, structpbValueToKindStringGo(v.Atom.ComparisonValue))
			if staticContext {
				return fmt.Sprintf("ctx.%s < %s", strcase.ToCamel(v.Atom.ContextKey), string(try.To1(protojson.Marshal(v.Atom.ComparisonValue))))
			} else {
				return fmt.Sprintf("%s < %s", strcase.ToLowerCamel(v.Atom.ContextKey), string(try.To1(protojson.Marshal(v.Atom.ComparisonValue))))
			}
		case rulesv1beta3.ComparisonOperator_COMPARISON_OPERATOR_LESS_THAN_OR_EQUALS:
			tryStoreUsedVariable(usedVariables, v.Atom.ContextKey, structpbValueToKindStringGo(v.Atom.ComparisonValue))
			if staticContext {
				return fmt.Sprintf("ctx.%s <= %s", strcase.ToCamel(v.Atom.ContextKey), string(try.To1(protojson.Marshal(v.Atom.ComparisonValue))))
			} else {
				return fmt.Sprintf("%s <= %s", strcase.ToLowerCamel(v.Atom.ContextKey), string(try.To1(protojson.Marshal(v.Atom.ComparisonValue))))
			}
		case rulesv1beta3.ComparisonOperator_COMPARISON_OPERATOR_GREATER_THAN:
			tryStoreUsedVariable(usedVariables, v.Atom.ContextKey, structpbValueToKindStringGo(v.Atom.ComparisonValue))
			if staticContext {
				return fmt.Sprintf("ctx.%s > %s", strcase.ToCamel(v.Atom.ContextKey), string(try.To1(protojson.Marshal(v.Atom.ComparisonValue))))
			} else {
				return fmt.Sprintf("%s > %s", strcase.ToLowerCamel(v.Atom.ContextKey), string(try.To1(protojson.Marshal(v.Atom.ComparisonValue))))
			}
		case rulesv1beta3.ComparisonOperator_COMPARISON_OPERATOR_GREATER_THAN_OR_EQUALS:
			tryStoreUsedVariable(usedVariables, v.Atom.ContextKey, structpbValueToKindStringGo(v.Atom.ComparisonValue))
			if staticContext {
				return fmt.Sprintf("ctx.%s >= %s", strcase.ToCamel(v.Atom.ContextKey), string(try.To1(protojson.Marshal(v.Atom.ComparisonValue))))
			} else {
				return fmt.Sprintf("%s >= %s", strcase.ToLowerCamel(v.Atom.ContextKey), string(try.To1(protojson.Marshal(v.Atom.ComparisonValue))))
			}
		case rulesv1beta3.ComparisonOperator_COMPARISON_OPERATOR_CONTAINS:
			tryStoreUsedVariable(usedVariables, v.Atom.ContextKey, structpbValueToKindStringGo(v.Atom.ComparisonValue))
			*usedStrings = true
			if staticContext {
				return fmt.Sprintf("strings.Contains(ctx.%s, %s)", strcase.ToCamel(v.Atom.ContextKey), string(try.To1(protojson.Marshal(v.Atom.ComparisonValue))))
			} else {
				return fmt.Sprintf("strings.Contains(%s,  %s)", strcase.ToLowerCamel(v.Atom.ContextKey), string(try.To1(protojson.Marshal(v.Atom.ComparisonValue))))
			}
		case rulesv1beta3.ComparisonOperator_COMPARISON_OPERATOR_STARTS_WITH:
			tryStoreUsedVariable(usedVariables, v.Atom.ContextKey, structpbValueToKindStringGo(v.Atom.ComparisonValue))
			*usedStrings = true
			if staticContext {
				return fmt.Sprintf("strings.HasPrefix(ctx.%s, %s)", strcase.ToCamel(v.Atom.ContextKey), string(try.To1(protojson.Marshal(v.Atom.ComparisonValue))))
			} else {
				return fmt.Sprintf("strings.HasPrefix(%s,  %s)", strcase.ToLowerCamel(v.Atom.ContextKey), string(try.To1(protojson.Marshal(v.Atom.ComparisonValue))))
			}
		case rulesv1beta3.ComparisonOperator_COMPARISON_OPERATOR_ENDS_WITH:
			tryStoreUsedVariable(usedVariables, v.Atom.ContextKey, structpbValueToKindStringGo(v.Atom.ComparisonValue))
			*usedStrings = true
			if staticContext {
				return fmt.Sprintf("strings.HasSuffix(ctx.%s, %s)", strcase.ToCamel(v.Atom.ContextKey), string(try.To1(protojson.Marshal(v.Atom.ComparisonValue))))
			} else {
				return fmt.Sprintf("strings.HasSuffix(%s,  %s)", strcase.ToLowerCamel(v.Atom.ContextKey), string(try.To1(protojson.Marshal(v.Atom.ComparisonValue))))
			}
		case rulesv1beta3.ComparisonOperator_COMPARISON_OPERATOR_CONTAINED_WITHIN:
			sliceType := "string"
			switch v.Atom.ComparisonValue.GetListValue().GetValues()[0].GetKind().(type) {
			case *structpb.Value_NumberValue:
				// technically doubles may not work for ints....
				sliceType = "float64"
			case *structpb.Value_BoolValue:
				sliceType = "bool"
			case *structpb.Value_StringValue:
				// technically doubles may not work for ints....
				sliceType = "string"
			}
			var elements []string
			for _, comparisonVal := range v.Atom.ComparisonValue.GetListValue().GetValues() {
				elements = append(elements, string(try.To1(protojson.Marshal(comparisonVal))))
			}
			tryStoreUsedVariable(usedVariables, v.Atom.ContextKey, sliceType)
			*usedSlices = true
			if staticContext {
				return fmt.Sprintf("slices.Contains([]%s{%s}, ctx.%s)", sliceType, strings.Join(elements, ", "), strcase.ToCamel(v.Atom.ContextKey))
			} else {
				return fmt.Sprintf("slices.Contains([]%s{%s}, %s)", sliceType, strings.Join(elements, ", "), strcase.ToLowerCamel(v.Atom.ContextKey))
			}
			// TODO, probably logical to have this here but we need slice syntax, use slices as of golang 1.21
		}
	case *rulesv1beta3.Rule_LogicalExpression:
		operator := " && "
		switch v.LogicalExpression.GetLogicalOperator() {
		case rulesv1beta3.LogicalOperator_LOGICAL_OPERATOR_OR:
			operator = " || "
		}
		var result []string
		for _, rule := range v.LogicalExpression.Rules {
			// worry about inner parens later
			result = append(result, translateRule(rule, staticContext, usedVariables, usedStrings, usedSlices))
		}
		return strings.Join(result, operator)
	}

	fmt.Printf("Need to learn how to: %+v\n", rule.GetRule())
	return ""
}

func FieldValueToString(parent protoreflect.Message, f protoreflect.FieldDescriptor, val protoreflect.Value, protoType *ProtoImport) string {
	if msg, ok := val.Interface().(protoreflect.Message); ok {
		// Try finding in type registry
		_, err := typeRegistry.FindMessageByName((msg.Descriptor().FullName()))
		if errors.Is(err, protoregistry.NotFound) {
			// Try finding in parent's nested message definitions
			nestedMsgDesc := parent.Descriptor().Messages().ByName(msg.Descriptor().Name())
			if nestedMsgDesc == nil {
				panic(fmt.Sprintf("unable to find message type %s", msg.Descriptor().FullName()))
			}
			return translateProtoValue(
				msg.Interface(),
				// Need to use original import info but with different nested type name
				&ProtoImport{
					ImportPath:   protoType.ImportPath,
					PackageAlias: protoType.PackageAlias,
					Type:         fmt.Sprintf("%s_%s", string(parent.Descriptor().Name()), string(nestedMsgDesc.Name())),
				},
			)
		} else if err != nil {
			panic(errors.Wrap(err, "unknown error while checking type registry"))
		}
		// Found in type registry
		return translateProtoValue(
			msg.Interface(),
			// TODO: We probably do need the root module here...?
			UnpackProtoType("", string(msg.Descriptor().FullName())),
		)
	} else {
		switch f.Kind() {
		case protoreflect.EnumKind:
			// TODO: Actually handle enums, right now they're just numbers
			return val.String()
		case protoreflect.StringKind:
			// If the string value is multiline, transform to raw literal instead
			valString := val.String()
			quote := "\""
			if strings.Count(valString, "\n") > 0 {
				quote = "`"
			}
			return fmt.Sprintf("%s%s%s", quote, val.String(), quote)
		case protoreflect.BoolKind:
			return val.String()
		case protoreflect.BytesKind:
			panic("Don't know how to take bytes, try nibbles")
		case protoreflect.FloatKind:
			fallthrough
		case protoreflect.DoubleKind:
			fallthrough
		case protoreflect.Int64Kind:
			fallthrough
		case protoreflect.Int32Kind:
			fallthrough
		case protoreflect.Uint64Kind:
			fallthrough
		case protoreflect.Uint32Kind:
			return val.String()
		case protoreflect.MessageKind:
			if f.IsMap() {
				var lines []string
				res := fmt.Sprintf("map[%s]%s{", f.MapKey().Kind().String(), f.MapValue().Kind().String()) // TODO - this probbaly breaks for nested
				val.Map().Range(func(mk protoreflect.MapKey, mv protoreflect.Value) bool {
					lines = append(lines, fmt.Sprintf("\"%s\": %s",
						mk.String(),
						FieldValueToString(parent, f.MapValue(), mv, protoType)))
					return true
				})
				if len(lines) > 1 {
					slices.Sort(lines)
					res += "\n"
					res += strings.Join(lines, ",\n")
					res += ",\n}"
				} else {
					res += strings.Join(lines, "")
					res += "}"
				}
				return res
			} else if f.IsList() {
				panic(fmt.Sprintf("Do not know how to count: %+v", f))
			}
		default:
			panic(fmt.Sprintf("Unknown: %+v", f))
		}
	}
	panic("Unreachable code was reached")
}

func translateAnyValue(val *anypb.Any, protoType *ProtoImport) string {
	msg, err := anypb.UnmarshalNew(val, proto.UnmarshalOptions{Resolver: typeRegistry})
	if err != nil {
		panic(errors.Wrap(err, "unmarshal return value"))
	}
	if protoType == nil {
		// TODO we may need more special casing here for primitive types.
		// This feels like horrific syntax, but I needed this because
		// Int64 was somehow serializing to "1" instead of 1, and typechecking
		// doesn't seem to work since `UnmarshalNew` returns a `dynamicpb.Message` which doesn't work with go's type casing.
		if val.MessageIs((*wrapperspb.Int64Value)(nil)) {
			var i64 wrapperspb.Int64Value
			try.To(val.UnmarshalTo(&i64))
			return strconv.FormatInt(i64.Value, 10)
		}
		if val.MessageIs((*wrapperspb.StringValue)(nil)) {
			var s wrapperspb.StringValue
			try.To(val.UnmarshalTo(&s))
			// If multiline string value, gen as raw string literal instead
			quote := "\""
			if strings.Count(s.Value, "\n") > 0 {
				quote = "`"
			}
			return fmt.Sprintf("%s%s%s", quote, s.Value, quote)
		}
		return string(try.To1(protojson.Marshal(msg)))
	}
	return translateProtoValue(msg, protoType)
}

func translateProtoValue(msg protoreflect.ProtoMessage, protoType *ProtoImport) string {
	// todo multiline formatting
	var lines []string
	msg.ProtoReflect().Range(func(f protoreflect.FieldDescriptor, val protoreflect.Value) bool {
		lines = append(lines, fmt.Sprintf("%s: %s", strcase.ToCamel(f.TextName()), FieldValueToString(msg.ProtoReflect(), f, val, protoType)))
		return true
	})
	if len(lines) > 1 {
		slices.Sort(lines)
		// Replace this with interface pointing stuff
		return fmt.Sprintf("&%s.%s{\n%s,\n}", protoType.PackageAlias, protoType.Type, strings.Join(lines, ",\n"))
	} else {
		return fmt.Sprintf("&%s.%s{%s}", protoType.PackageAlias, protoType.Type, strings.Join(lines, ""))
	}
}

// TODO: Generify
// Get all unique possible return values of a config
func getStringRetValues(f *featurev1beta1.Feature) []string {
	if f.Type != featurev1beta1.FeatureType_FEATURE_TYPE_STRING {
		return []string{}
	}
	valSet := make(map[string]bool)
	valSet[translateAnyValue(f.Tree.Default, nil)] = true
	for _, constraint := range f.Tree.Constraints {
		ret := translateAnyValue(constraint.Value, nil)
		valSet[ret] = true
	}
	var rets []string
	for val := range valSet {
		rets = append(rets, val)
	}
	sort.Strings(rets)
	return rets
}

func genClientFile(moduleRoot string) error {
	// Template for generated client initialization code.
	// TODO: consider an ergonomic way of letting caller know that static fallback will be used due to failed remote init
	const clientTemplateBody = `// Generated by Lekko. DO NOT EDIT.
package lekko

import (
	"context"
	"errors"
	"os"

	client "github.com/lekkodev/go-sdk/client"
	{{- range $.Namespaces}}
	{{nsToImport .}}{{end}}
	"google.golang.org/protobuf/proto"
)

type LekkoClient struct {
	{{- range $.Namespaces}}
	{{nsToClientFieldType .}}{{end}}
	Close client.CloseFunc
}

// Initializes the Lekko SDK client.
// For remote configs to be fetched correctly, the LEKKO_API_KEY, LEKKO_REPOSITORY_OWNER, and LEKKO_REPOSITORY_NAME env variables are required.
// If these values are missing or if there are any connection errors, the static fallbacks will be used.
func NewLekkoClient(ctx context.Context) *LekkoClient {
	apiKey := os.Getenv("LEKKO_API_KEY")
	repoOwner := os.Getenv("LEKKO_REPOSITORY_OWNER")
	repoName := os.Getenv("LEKKO_REPOSITORY_NAME")
	provider, err := client.CachedAPIProvider(ctx, &client.RepositoryKey{
		OwnerName: repoOwner,
		RepoName: repoName,
	}, client.WithAPIKey(apiKey))
	if err != nil {
		provider = &noOpProvider{}
	}
	cli, close := client.NewClient(provider)
	return &LekkoClient{
		{{- range $.Namespaces}}
		{{nsToClientField .}},{{end}}
		Close: close,
	}
}

type noOpProvider struct {}

func (p *noOpProvider) GetBool(ctx context.Context, key string, namespace string) (bool, error) {
	return false, errors.New("not implemented")
}
func (p *noOpProvider) GetInt(ctx context.Context, key string, namespace string) (int64, error) {
	return 0, errors.New("not implemented")
}
func (p *noOpProvider) GetFloat(ctx context.Context, key string, namespace string) (float64, error) {
	return 0, errors.New("not implemented")
}
func (p *noOpProvider) GetString(ctx context.Context, key string, namespace string) (string, error) {
	return "", errors.New("not implemented")
}
func (p *noOpProvider) GetProto(ctx context.Context, key string, namespace string, result proto.Message) error {
	return errors.New("not implemented")
}
func (p *noOpProvider) GetJSON(ctx context.Context, key string, namespace string, result interface{}) error {
	return errors.New("not implemented")
}
func (p *noOpProvider) Close(ctx context.Context) error {
	return nil
}
`

	clientTemplateData := struct {
		Namespaces []string
	}{
		[]string{},
	}
	clientTemplateFuncs := map[string]any{
		"nsToImport": func(ns string) string {
			return fmt.Sprintf("lekko%s \"%s/%s/%s\"", ns, moduleRoot, defaultOutputPath, ns)
		},
		"nsToClientFieldType": func(ns string) string {
			return fmt.Sprintf("%s *lekko%s.LekkoClient", strcase.ToCamel(ns), ns)
		},
		"nsToClientField": func(ns string) string {
			return fmt.Sprintf("%s: &lekko%s.LekkoClient{Client: cli}", strcase.ToCamel(ns), ns)
		},
	}
	// Walk through lekko/ directory to find namespaces
	// We walk through dir instead of just using the namespace from above because shared client init code should include every namespace
	if err := filepath.WalkDir(defaultOutputPath, func(path string, d fs.DirEntry, err error) error {
		// Ignore files and root and proto directory - this will need to be updated if we ever change proto gen
		if path == defaultOutputPath || !d.IsDir() {
			return nil
		}
		if d.Name() == "proto" {
			return filepath.SkipDir
		}
		clientTemplateData.Namespaces = append(clientTemplateData.Namespaces, d.Name())
		return filepath.SkipDir
	}); err != nil {
		return errors.Wrap(err, "generate client initialization code: walk namespaces")
	}
	var contents bytes.Buffer
	templ := template.Must(template.New("client").Funcs(clientTemplateFuncs).Parse(clientTemplateBody))
	if err := templ.Execute(&contents, clientTemplateData); err != nil {
		return errors.Wrap(err, "generate client initialization code: template exec")
	}
	formatted, err := format.Source(contents.Bytes())
	if err != nil {
		return errors.Wrap(err, "generation client initialization code: format")
	}
	f, err := os.Create(path.Join(defaultOutputPath, "client_gen.go"))
	if err != nil {
		return errors.Wrap(err, "generate client initialization code: create file")
	}
	if _, err := f.Write(formatted); err != nil {
		return errors.Wrap(err, fmt.Sprintf("write formatted contents to %s", f.Name()))
	}
	return nil
}
