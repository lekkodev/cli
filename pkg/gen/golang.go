// Copyright 2022 Lekko Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package gen

import (
	"bytes"
	"context"
	"fmt"
	"go/format"
	"os"
	"path"
	"path/filepath"
	"regexp"
	"slices"
	"sort"
	"strconv"
	"strings"
	"text/template"

	featurev1beta1 "buf.build/gen/go/lekkodev/cli/protocolbuffers/go/lekko/feature/v1beta1"
	rulesv1beta3 "buf.build/gen/go/lekkodev/cli/protocolbuffers/go/lekko/rules/v1beta3"
	"github.com/iancoleman/strcase"
	"github.com/lainio/err2"
	"github.com/lainio/err2/assert"
	"github.com/lainio/err2/try"
	"github.com/lekkodev/cli/pkg/dotlekko"
	"github.com/lekkodev/cli/pkg/repo"
	"github.com/pkg/errors"
	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/reflect/protoregistry"
	"google.golang.org/protobuf/types/known/anypb"
	"google.golang.org/protobuf/types/known/structpb"
	"google.golang.org/protobuf/types/known/wrapperspb"

	"github.com/lekkodev/cli/pkg/native"
)

// TODO: this can hold more state to clean up functions a bit, like storing usedVariables, etc.
type goGenerator struct {
	moduleRoot   string
	outputPath   string // Location for destination file, can be absolute or relative. Its suffix should be the same as lekkoPath. In most cases can be same as lekkoPath.
	lekkoPath    string // Location relative to project root where Lekko files are stored, e.g. internal/lekko.
	repoPath     string
	namespace    string
	TypeRegistry *protoregistry.Types
}

func NewGoGenerator(moduleRoot, outputPath, lekkoPath, repoPath, namespace string) (*goGenerator, error) {
	// Validate namespace
	if !regexp.MustCompile("[a-z]+").MatchString(namespace) {
		return nil, fmt.Errorf("namespace must be a lowercase alphabetic string: %s", namespace)
	}
	if namespace == "proto" {
		return nil, errors.New("'proto' is a reserved name")
	}

	return &goGenerator{
		moduleRoot: moduleRoot,
		outputPath: outputPath,
		lekkoPath:  filepath.Clean(lekkoPath),
		repoPath:   repoPath,
		namespace:  namespace,
	}, nil
}

// TODO make this work for GO
func structpbValueToKindStringGo(v *structpb.Value) string {
	switch v.GetKind().(type) {
	case *structpb.Value_NumberValue:
		// TODO: figure out how to handle this ambiguity better
		return "float64"
	case *structpb.Value_BoolValue:
		return "bool"
	case *structpb.Value_StringValue:
		return "string"
	}
	return "unknown" // do we just want to panic?
}

// Initialize a blank Lekko config function file
func (g *goGenerator) Init(ctx context.Context) error {
	const templateBody = `package lekko{{$.Namespace}}

// This is an example description for an example config
func getExample() bool {
	return true
}`
	fullOutputPath := path.Join(g.outputPath, g.namespace, fmt.Sprintf("%s.go", g.namespace))
	if _, err := os.Stat(fullOutputPath); err == nil {
		return fmt.Errorf("file %s already exists", fullOutputPath)
	}

	data := struct {
		Namespace string
	}{
		Namespace: g.namespace,
	}
	var contents bytes.Buffer
	templ := template.Must(template.New(fullOutputPath).Parse(templateBody))
	if err := templ.Execute(&contents, data); err != nil {
		return errors.Wrapf(err, "%s template", fullOutputPath)
	}
	formatted, err := format.Source(contents.Bytes())
	if err != nil {
		return errors.Wrapf(err, "format %s", fullOutputPath)
	}
	try.To(os.MkdirAll(path.Join(g.outputPath, g.namespace), 0770))
	f, err := os.Create(fullOutputPath)
	if err != nil {
		return errors.Wrapf(err, "create %s", fullOutputPath)
	}
	if _, err := f.Write(formatted); err != nil {
		return errors.Wrapf(err, "write %s", fullOutputPath)
	}
	return nil
}

// This is an attempt to pull out a simpler component that is more re-usable - the other one should probably be removed/changed, but that depends on
// how far this change goes
func (g *goGenerator) GenNamespaceFiles(ctx context.Context, features []*featurev1beta1.Feature, staticCtxType *ProtoImport) (string, string, error) {
	// For each namespace, we want to generate under lekko/:
	// lekko/
	//   <namespace>/
	//     <namespace>.go
	//     <namespace>_gen.go

	// <namespace>.go is meant to be edited by the user, contains private native lang funcs
	// <namespace>_gen.go is marked as machine-generated, contains public funcs to be used in application code

	const publicFileTemplateBody = `// Generated by Lekko. DO NOT EDIT.
package lekko{{$.Namespace}}

import (
	"context"
	"log"
{{if $.ImportProtoReflect}}
	"google.golang.org/protobuf/reflect/protoreflect"
{{else}}{{end}}
{{range $.ProtoImports}}
	{{ . }}{{end}}
	client "github.com/lekkodev/go-sdk/client"
)

type LekkoClient struct {
client.Client
}

{{range $.PublicFuncStrings}}
{{ . }}{{end}}`

	// TODOs for the template:
	// - make sure to test if slices is valid depending on go versions
	// - add go generate directive to invoke this command
	//   - but if doing 2-way and directive already exists, should respect original
	const privateFileTemplateBody = `package lekko{{$.Namespace}}

{{if or $.AddStringsImport $.AddSlicesImport (gt (len $.ProtoImports) 0)}}
import (
	{{if $.AddStringsImport}}"strings"{{end}}
{{range $.ProtoImports}}
	{{ . }}{{end}}
	{{if $.AddSlicesImport}}"golang.org/x/exp/slices"{{end}}
)
{{end}}

{{range $.StructDefs}}
{{ . }}{{end}}
{{range $.PrivateFuncStrings}}
{{ . }}{{end}}`

	var publicFuncStrings []string
	var privateFuncStrings []string
	protoImportSet := make(map[string]*ProtoImport)
	addStringsImport := false
	addSlicesImport := false
	StructDefMap := make(map[string]string)
	importProtoReflect := false
	for _, f := range features {
		var ctxType *ProtoImport
		messagePath := fmt.Sprintf("%s.config.v1beta1.%sArgs", g.namespace, strcase.ToCamel(f.Key))
		mt, err := g.TypeRegistry.FindMessageByName(protoreflect.FullName(messagePath))
		if err == nil {
			privateFuncStrings = append(privateFuncStrings, DescriptorToStructDeclaration(mt.Descriptor()))
			ctxType = &ProtoImport{Type: string(mt.Descriptor().Name()), TypeUrl: "type.googleapis.com/" + messagePath}
		} else {
			ctxType = staticCtxType
		}

		if f.Type == featurev1beta1.FeatureType_FEATURE_TYPE_PROTO {
			msg, err := anypb.UnmarshalNew(f.Tree.Default, proto.UnmarshalOptions{Resolver: g.TypeRegistry})
			if err != nil {
				fmt.Printf("%+v\n\n", g.TypeRegistry)
				panic(errors.Wrapf(err, "%s", f.Tree.Default.TypeUrl))
			}
			if msg.ProtoReflect().Descriptor().FullName() != "google.protobuf.Duration" {
				// This feels bad...
				StructDefMap[f.Tree.Default.TypeUrl] = DescriptorToStructDeclaration(msg.ProtoReflect().Descriptor())
			}
			importProtoReflect = true
		}

		generated, err := g.genGoForFeature(ctx, nil, f, g.namespace, ctxType)
		if err != nil {
			return "", "", errors.Wrapf(err, "generate code for %s/%s", g.namespace, f.Key)
		}
		publicFuncStrings = append(publicFuncStrings, generated.public)
		privateFuncStrings = append(privateFuncStrings, generated.private)
		if generated.usedStrings {
			addStringsImport = true
		}
		if generated.usedSlices {
			addSlicesImport = true
		}
		if f.Type == featurev1beta1.FeatureType_FEATURE_TYPE_PROTO {
			// TODO: Return imports from gen methods and collect, this doesn't handle imports for nested
			protoImport := UnpackProtoType(g.moduleRoot, g.lekkoPath, f.Tree.Default.TypeUrl)
			if protoImport.PackageAlias != "" {
				protoImportSet[protoImport.ImportPath] = protoImport
			}
		}
	}

	var protoImports []string
	for _, imp := range protoImportSet {
		protoImports = append(protoImports, fmt.Sprintf(`%s "%s"`, imp.PackageAlias, imp.ImportPath))
	}

	var structDefs []string
	for _, sd := range StructDefMap {
		structDefs = append(structDefs, sd)
	}
	sort.Strings(structDefs)

	data := struct {
		ProtoImports       []string
		Namespace          string
		PublicFuncStrings  []string
		PrivateFuncStrings []string
		AddStringsImport   bool
		AddSlicesImport    bool
		StructDefs         []string
		ImportProtoReflect bool
	}{
		protoImports,
		g.namespace,
		publicFuncStrings,
		privateFuncStrings,
		addStringsImport,
		addSlicesImport,
		structDefs,
		importProtoReflect,
	}

	public, err := getContents(publicFileTemplateBody, fmt.Sprintf("%s_gen.go", g.namespace), data)
	if err != nil {
		return "", "", err
	}
	private, err := getContents(privateFileTemplateBody, fmt.Sprintf("%s.go", g.namespace), data)
	if err != nil {
		return "", "", err
	}

	return public, private, nil
}

func getContents(templateBody string, fileName string, data any) (string, error) {
	var contents bytes.Buffer
	templ := template.Must(template.New(fileName).Parse(templateBody))
	if err := templ.Execute(&contents, data); err != nil {
		return "", errors.Wrap(err, fmt.Sprintf("%s template", fileName))
	}

	// Final canonical Go format
	formatted, err := format.Source(contents.Bytes())
	if err != nil {
		return "", errors.Wrap(err, fmt.Sprintf("format %s\n %s\n\n", fileName, contents.String()))
	}
	return string(formatted), nil
}

func (g *goGenerator) Gen(ctx context.Context) (err error) {
	defer err2.Handle(&err)
	r, err := repo.NewLocal(g.repoPath, nil)
	if err != nil {
		return errors.Wrap(err, "read config repository")
	}
	rootMD, nsMDs := try.To2(r.ParseMetadata(ctx))
	if g.TypeRegistry == nil {
		// TODO this feels weird and there is a global set we should be able to add to but I'll worrry about it later?
		g.TypeRegistry = try.To1(r.BuildDynamicTypeRegistry(ctx, rootMD.ProtoDirectory))
	}
	nsMD, ok := nsMDs[g.namespace]
	if !ok {
		return fmt.Errorf("%s is not a namespace in the config repository", g.namespace)
	}
	staticCtxType := UnpackProtoType(g.moduleRoot, g.lekkoPath, nsMD.ContextProto)
	ffs, err := r.GetFeatureFiles(ctx, g.namespace)
	if err != nil {
		return err
	}
	// Sort configs in alphabetical order
	sort.SliceStable(ffs, func(i, j int) bool {
		return ffs[i].CompiledProtoBinFileName < ffs[j].CompiledProtoBinFileName
	})
	var features []*featurev1beta1.Feature
	for _, ff := range ffs {
		fff, err := os.ReadFile(path.Join(g.repoPath, g.namespace, ff.CompiledProtoBinFileName))
		if err != nil {
			return err
		}
		f := &featurev1beta1.Feature{}
		if err := proto.Unmarshal(fff, f); err != nil {
			return err
		}
		features = append(features, f)
	}
	// Create intermediate directories for output
	if err := os.MkdirAll(path.Join(g.outputPath, g.namespace), 0770); err != nil {
		return err
	}
	public, private, err := g.GenNamespaceFiles(ctx, features, staticCtxType)
	if err != nil {
		return err
	}
	if f, err := os.Create(path.Join(g.outputPath, g.namespace, fmt.Sprintf("%s_gen.go", g.namespace))); err != nil {
		return err
	} else {
		if _, err := f.WriteString(public); err != nil {
			return errors.Wrap(err, fmt.Sprintf("write formatted contents to %s", f.Name()))
		}
	}
	if f, err := os.Create(path.Join(g.outputPath, g.namespace, fmt.Sprintf("%s.go", g.namespace))); err != nil {
		return err
	} else {
		if _, err := f.WriteString(private); err != nil {
			return errors.Wrap(err, fmt.Sprintf("write formatted contents to %s", f.Name()))
		}
	}
	return g.genClientFile(g.moduleRoot)
}

type generatedConfigCode struct {
	// "Generated" code, public interface for consumption
	public string
	// For user creation/editing
	private string
	// Whether the std package "strings" was used
	usedStrings bool
	// Whether the std package "slices" was used
	usedSlices bool
}

type configCodeTemplate struct {
	public  string
	private string
}

// Template body for primitive config code
func (g *goGenerator) getDefaultTemplateBody() *configCodeTemplate {
	return &configCodeTemplate{
		public: `// {{$.Description}}
func (c *LekkoClient) {{$.FuncName}}({{$.ArgumentString}}) {{$.RetType}} {
  	{{ $.CtxStuff }}
	 log.Printf("Lekko getting {{$.Namespace}}.{{$.Key}}\n" )
  	result, err := c.{{$.GetFunction}}(ctx, "{{$.Namespace}}", "{{$.Key}}")
	if err == nil {
	  	return result
  	}
	log.Printf("Lekko static fallback with error: %s\n", err)
  	return {{$.PrivateFunc}}({{$.CallString}})
}`,
		private: `// {{$.Description}}
func {{$.PrivateFunc}}({{$.ArgumentString}}) {{$.RetType}} {
{{range  $.NativeLanguage}}{{ . }}
{{end}}}`,
	}
}

// Template body for proto config code
func (g *goGenerator) getProtoTemplateBody() *configCodeTemplate {
	return &configCodeTemplate{
		public: `// {{$.Description}}
func (c *LekkoClient) {{$.FuncName}}({{$.ArgumentString}}) *{{$.RetType}} {
		{{ $.CtxStuff }}
    ret := &{{$.RetType}}{}
	log.Printf("Lekko getting {{$.Namespace}}.{{$.Key}}\n" )
	result, err := c.GetAny(ctx, "{{$.Namespace}}", "{{$.Key}}")
	if err == nil {
	{{$.ProtoStructFilling}}
			return ret
		}
		log.Printf("Lekko static fallback with error: %s\n", err)
		return {{$.PrivateFunc}}({{$.CallString}})
}`,
		private: `// {{$.Description}}
func {{$.PrivateFunc}}({{$.ArgumentString}}) *{{$.RetType}} {
{{range  $.NativeLanguage}}{{ . }}
{{end}}}`,
	}
}

// Template body for configs that are top-level enums
// TODO: This isn't actually supported, figure this out as well
// Includes const declarations for the enums
func (g *goGenerator) getStringEnumTemplateBody() *configCodeTemplate {
	return &configCodeTemplate{
		public: `type {{$.EnumTypeName}} string
const (
	{{range $index, $field := $.EnumFields}}{{$field.Name}} {{$.EnumTypeName}} = "{{$field.Value}}"
	{{end}}
)

// {{$.Description}}
func (c *LekkoClient) {{$.FuncName}}({{$.ArgumentString}}) {{$.RetType}} {
		{{ $.CtxStuff }}
		result, err := c.{{$.GetFunction}}(ctx, "{{$.Namespace}}", "{{$.Key}}")
	if err == nil {
			return result
		}
		return {{$.PrivateFunc}}({{$.CallString}})
}`,
		private: `type {{$.EnumTypeName}} string
const (
	{{range $index, $field := $.EnumFields}}{{$field.Name}} {{$.EnumTypeName}} = "{{$field.Value}}"
	{{end}}
)

// {{$.Description}}
func {{$.PrivateFunc}}({{$.ArgumentString}}) {{$.RetType}} {
{{range  $.NativeLanguage}}{{ . }}
{{end}}}`,
	}
}

func (g *goGenerator) genGoForFeature(ctx context.Context, r repo.ConfigurationRepository, f *featurev1beta1.Feature, ns string, staticCtxType *ProtoImport) (*generatedConfigCode, error) {
	var funcNameBuilder strings.Builder
	funcNameBuilder.WriteString("Get")
	for _, word := range regexp.MustCompile("[_-]+").Split(f.Key, -1) {
		funcNameBuilder.WriteString(strings.ToUpper(word[:1]) + word[1:])
	}
	funcName := funcNameBuilder.String()
	privateFunc := strcase.ToLowerCamel(funcName)
	var retType string
	var getFunction string
	var enumTypeName string
	var protoStructFilling string
	type EnumField struct {
		Name  string
		Value string
	}
	var enumFields []EnumField
	templateBody := g.getDefaultTemplateBody()

	var protoType *ProtoImport
	switch f.Type {
	case featurev1beta1.FeatureType_FEATURE_TYPE_BOOL:
		retType = "bool"
		getFunction = "GetBool"
	case featurev1beta1.FeatureType_FEATURE_TYPE_INT:
		retType = "int64"
		getFunction = "GetInt"
	case featurev1beta1.FeatureType_FEATURE_TYPE_FLOAT:
		retType = "float64"
		getFunction = "GetFloat"
	case featurev1beta1.FeatureType_FEATURE_TYPE_STRING:
		retType = "string"
		getFunction = "GetString"
		if r != nil {
			// HACK: The metadata field is only for presentation at the moment
			// so is not part of the compiled object - need to statically parse
			// This also means that this only works for statically parseable
			// configs
			sf, err := r.Parse(ctx, ns, f.Key, g.TypeRegistry) // TODO - wtf is this about? - just enums right?
			if err != nil {
				return nil, errors.Wrap(err, "static parsing")
			}
			fm := sf.Feature.Metadata.AsMap()
			// TODO: This enum codegen does not handle possible conflicts at all
			if genEnum, ok := fm["gen-enum"]; ok {
				if genEnumBool, ok := genEnum.(bool); ok && genEnumBool {
					enumTypeName = strcase.ToCamel(f.Key)
					retType = enumTypeName
					templateBody = g.getStringEnumTemplateBody()
					for _, ret := range g.getStringRetValues(f) {
						// Result of translating ret values is wrapped in quotes
						ret = ret[1 : len(ret)-1]
						name := enumTypeName
						if ret == "" {
							name += "Unspecified"
						} else {
							name += strcase.ToCamel(ret)
						}
						enumFields = append(enumFields, EnumField{
							Name:  name,
							Value: ret,
						})
					}
				}
			}
		}
	case featurev1beta1.FeatureType_FEATURE_TYPE_JSON:
		// TODO: Actually figure out how we want to do json configs
		return nil, fmt.Errorf("unsupported json config %s/%s", ns, f.Key)
	case featurev1beta1.FeatureType_FEATURE_TYPE_PROTO:
		getFunction = "GetProto"
		templateBody = g.getProtoTemplateBody()
		matched, err := regexp.MatchString(fmt.Sprintf("type.googleapis.com/%s.config.v1beta1.[a-zA-Z0-9]", ns), f.Tree.Default.TypeUrl)
		if err != nil {
			panic(err)
		}
		if matched {
			parts := strings.Split(f.Tree.Default.TypeUrl, ".")
			retType = parts[len(parts)-1]
			protoType = UnpackProtoType(g.moduleRoot, g.lekkoPath, f.Tree.Default.TypeUrl)
			protoType.PackageAlias = ""
			// TODO - dups
		} else { // For things like returning WKT like Duration
			protoType = UnpackProtoType(g.moduleRoot, g.lekkoPath, f.Tree.Default.TypeUrl)
			retType = fmt.Sprintf("%s.%s", protoType.PackageAlias, protoType.Type)
		}
		mt, err := g.TypeRegistry.FindMessageByURL(f.Tree.Default.TypeUrl)
		if err != nil {
			panic(err)
		}
		protoStructFilling = `result.ProtoReflect().Range(func(fd protoreflect.FieldDescriptor, v protoreflect.Value) bool {
						switch fd.Name() {`
		for i := 0; i < mt.Descriptor().Fields().Len(); i++ {
			fd := mt.Descriptor().Fields().Get(i)
			fieldName := fd.Name()
			fieldType := FieldDescriptorToGoTypeString(fd)
			protoStructFilling = protoStructFilling + fmt.Sprintf(`
		case "%[1]s":
							v, ok := result.ProtoReflect().Get(fd).Interface().(%[2]s)
							if (ok) {
								ret.%[1]s = v
							}`, strcase.ToCamel(string(fieldName)), fieldType)
		}
		protoStructFilling = protoStructFilling + `
		}
		 return true
					})`
	}

	data := struct {
		Description        string
		FuncName           string
		PrivateFunc        string
		GetFunction        string
		RetType            string
		Namespace          string
		Key                string
		NativeLanguage     []string
		ArgumentString     string
		CallString         string
		EnumTypeName       string
		EnumFields         []EnumField
		CtxStuff           string
		ProtoStructFilling string
	}{
		f.Description,
		funcName,
		privateFunc,
		getFunction,
		retType,
		ns,
		f.Key,
		[]string{},
		"",
		"",
		enumTypeName,
		enumFields,
		"",
		protoStructFilling,
	}
	generated := &generatedConfigCode{}
	usedVariables := make(map[string]string)
	if staticCtxType != nil {
		data.NativeLanguage = g.translateFeature(f, protoType, true, usedVariables, &generated.usedStrings, &generated.usedSlices)
		if staticCtxType.PackageAlias != "" {
			data.ArgumentString = fmt.Sprintf("args *%s.%s", staticCtxType.PackageAlias, staticCtxType.Type)
		} else {
			data.ArgumentString = fmt.Sprintf("args *%s", staticCtxType.Type)
		}
		data.CallString = "args"
		data.CtxStuff = "ctx := context.Background()\n"
		mt, err := g.TypeRegistry.FindMessageByURL(staticCtxType.TypeUrl)
		if err != nil {
			fmt.Printf("%#v\n", staticCtxType)
			println(staticCtxType.TypeUrl)
			panic(err)
		}
		for i := 0; i < mt.Descriptor().Fields().Len(); i++ {
			fd := mt.Descriptor().Fields().Get(i)
			fieldName := string(fd.Name())
			data.CtxStuff = data.CtxStuff + fmt.Sprintf("ctx = client.Add(ctx, \"%s\", args.%s)\n", fieldName, strcase.ToCamel(fieldName))
		}
	} else {
		data.CtxStuff = "ctx := context.Background()\n"
		data.NativeLanguage = g.translateFeature(f, protoType, false, usedVariables, &generated.usedStrings, &generated.usedSlices)
		var arguments []string
		var ctxAddLines []string
		for f, t := range usedVariables {
			arguments = append(arguments, fmt.Sprintf("%s %s", strcase.ToLowerCamel(f), t))
			ctxAddLines = append(ctxAddLines, fmt.Sprintf("ctx = client.Add(ctx, \"%s\", %s)", f, strcase.ToLowerCamel(f)))
		}
		// TODO: Sorting by name might not be the best solution for long-term UX... but it's simple and it works for now
		slices.Sort(arguments)
		slices.Sort(ctxAddLines)
		data.ArgumentString = strings.Join(arguments, ", ")
		data.CtxStuff += strings.Join(ctxAddLines, "\n")
		var keys []string
		for f := range usedVariables {
			keys = append(keys, strcase.ToLowerCamel(f))
		}
		slices.Sort(keys)
		data.CallString = strings.Join(keys, ", ")
	}
	if templ, err := template.New("public func").Parse(templateBody.public); err != nil {
		return nil, err
	} else {
		var ret bytes.Buffer
		if err := templ.Execute(&ret, data); err != nil {
			return nil, err
		}
		generated.public = ret.String()
	}
	if templ, err := template.New("private func").Parse(templateBody.private); err != nil {
		return nil, err
	} else {
		var ret bytes.Buffer
		if err := templ.Execute(&ret, data); err != nil {
			return nil, err
		}
		generated.private = ret.String()
	}
	return generated, nil
}

func (g *goGenerator) translateFeature(f *featurev1beta1.Feature, protoType *ProtoImport, staticContext bool, usedVariables map[string]string, usedStrings, usedSlices *bool) []string {
	var buffer []string
	for i, constraint := range f.Tree.Constraints {
		ifToken := "} else if"
		if i == 0 {
			ifToken = "if"
		}
		rule := g.translateRule(constraint.GetRuleAstNew(), staticContext, usedVariables, usedStrings, usedSlices)
		buffer = append(buffer, fmt.Sprintf("\t%s %s {", ifToken, rule))

		// TODO this doesn't work for proto, but let's try
		buffer = append(buffer, fmt.Sprintf("\t\treturn %s", g.translateAnyValue(constraint.Value, protoType)))
	}
	if len(f.Tree.Constraints) > 0 {
		buffer = append(buffer, "\t}")
	}
	buffer = append(buffer, fmt.Sprintf("\treturn %s", g.translateAnyValue(f.GetTree().GetDefault(), protoType)))
	return buffer
}

// If one key is used in the context of more than one type, we should fail
func (g *goGenerator) tryStoreUsedVariable(usedVariables map[string]string, k string, t string) {
	existT, ok := usedVariables[k]
	if !ok {
		usedVariables[k] = t
		return
	}
	assert.Equal(t, existT)
}

// Recursively translate a rule, which is an n-ary tree. See lekko.rules.v1beta3.Rule.
func (g *goGenerator) translateRule(rule *rulesv1beta3.Rule, staticContext bool, usedVariables map[string]string, usedStrings, usedSlices *bool) string {
	if rule == nil {
		return ""
	}
	switch v := rule.GetRule().(type) {
	case *rulesv1beta3.Rule_Atom:
		var contextKeyName string
		if staticContext {
			contextKeyName = fmt.Sprintf("args.%s", strcase.ToCamel(v.Atom.ContextKey))
		} else {
			contextKeyName = strcase.ToLowerCamel(v.Atom.ContextKey)
		}

		switch v.Atom.GetComparisonOperator() {
		case rulesv1beta3.ComparisonOperator_COMPARISON_OPERATOR_EQUALS:
			if b, ok := v.Atom.ComparisonValue.GetKind().(*structpb.Value_BoolValue); ok {
				g.tryStoreUsedVariable(usedVariables, v.Atom.ContextKey, "bool")
				if b.BoolValue {
					return contextKeyName
				} else {
					return fmt.Sprintf("!%s", contextKeyName)
				}
			}
			g.tryStoreUsedVariable(usedVariables, v.Atom.ContextKey, structpbValueToKindStringGo(v.Atom.ComparisonValue))
			return fmt.Sprintf("%s == %s", contextKeyName, string(try.To1(protojson.Marshal(v.Atom.ComparisonValue))))
		case rulesv1beta3.ComparisonOperator_COMPARISON_OPERATOR_NOT_EQUALS:
			g.tryStoreUsedVariable(usedVariables, v.Atom.ContextKey, structpbValueToKindStringGo(v.Atom.ComparisonValue))
			return fmt.Sprintf("%s != %s", contextKeyName, string(try.To1(protojson.Marshal(v.Atom.ComparisonValue))))
		case rulesv1beta3.ComparisonOperator_COMPARISON_OPERATOR_LESS_THAN:
			g.tryStoreUsedVariable(usedVariables, v.Atom.ContextKey, structpbValueToKindStringGo(v.Atom.ComparisonValue))
			return fmt.Sprintf("%s < %s", contextKeyName, string(try.To1(protojson.Marshal(v.Atom.ComparisonValue))))
		case rulesv1beta3.ComparisonOperator_COMPARISON_OPERATOR_LESS_THAN_OR_EQUALS:
			g.tryStoreUsedVariable(usedVariables, v.Atom.ContextKey, structpbValueToKindStringGo(v.Atom.ComparisonValue))
			return fmt.Sprintf("%s <= %s", contextKeyName, string(try.To1(protojson.Marshal(v.Atom.ComparisonValue))))
		case rulesv1beta3.ComparisonOperator_COMPARISON_OPERATOR_GREATER_THAN:
			g.tryStoreUsedVariable(usedVariables, v.Atom.ContextKey, structpbValueToKindStringGo(v.Atom.ComparisonValue))
			return fmt.Sprintf("%s > %s", contextKeyName, string(try.To1(protojson.Marshal(v.Atom.ComparisonValue))))
		case rulesv1beta3.ComparisonOperator_COMPARISON_OPERATOR_GREATER_THAN_OR_EQUALS:
			g.tryStoreUsedVariable(usedVariables, v.Atom.ContextKey, structpbValueToKindStringGo(v.Atom.ComparisonValue))
			return fmt.Sprintf("%s >= %s", contextKeyName, string(try.To1(protojson.Marshal(v.Atom.ComparisonValue))))
		case rulesv1beta3.ComparisonOperator_COMPARISON_OPERATOR_CONTAINS:
			g.tryStoreUsedVariable(usedVariables, v.Atom.ContextKey, structpbValueToKindStringGo(v.Atom.ComparisonValue))
			*usedStrings = true
			return fmt.Sprintf("strings.Contains(%s,  %s)", contextKeyName, string(try.To1(protojson.Marshal(v.Atom.ComparisonValue))))
		case rulesv1beta3.ComparisonOperator_COMPARISON_OPERATOR_STARTS_WITH:
			g.tryStoreUsedVariable(usedVariables, v.Atom.ContextKey, structpbValueToKindStringGo(v.Atom.ComparisonValue))
			*usedStrings = true
			return fmt.Sprintf("strings.HasPrefix(%s,  %s)", contextKeyName, string(try.To1(protojson.Marshal(v.Atom.ComparisonValue))))
		case rulesv1beta3.ComparisonOperator_COMPARISON_OPERATOR_ENDS_WITH:
			g.tryStoreUsedVariable(usedVariables, v.Atom.ContextKey, structpbValueToKindStringGo(v.Atom.ComparisonValue))
			*usedStrings = true
			return fmt.Sprintf("strings.HasSuffix(%s,  %s)", contextKeyName, string(try.To1(protojson.Marshal(v.Atom.ComparisonValue))))
		case rulesv1beta3.ComparisonOperator_COMPARISON_OPERATOR_CONTAINED_WITHIN:
			sliceType := "string"
			switch v.Atom.ComparisonValue.GetListValue().GetValues()[0].GetKind().(type) {
			case *structpb.Value_NumberValue:
				// technically doubles may not work for ints....
				sliceType = "float64"
			case *structpb.Value_BoolValue:
				sliceType = "bool"
			case *structpb.Value_StringValue:
				// technically doubles may not work for ints....
				sliceType = "string"
			}
			var elements []string
			for _, comparisonVal := range v.Atom.ComparisonValue.GetListValue().GetValues() {
				elements = append(elements, string(try.To1(protojson.Marshal(comparisonVal))))
			}
			g.tryStoreUsedVariable(usedVariables, v.Atom.ContextKey, sliceType)
			*usedSlices = true
			return fmt.Sprintf("slices.Contains([]%s{%s}, %s)", sliceType, strings.Join(elements, ", "), contextKeyName)
			// TODO, probably logical to have this here but we need slice syntax, use slices as of golang 1.21
		default:
			panic(fmt.Errorf("unsupported operator %+v", v.Atom.ComparisonOperator))
		}
	case *rulesv1beta3.Rule_Not:
		ruleStrFmt := "!%s"
		// For some cases, we want to wrap the generated Go expression string in parens
		switch rule := v.Not.Rule.(type) {
		case *rulesv1beta3.Rule_LogicalExpression:
			ruleStrFmt = "!(%s)"
		case *rulesv1beta3.Rule_Atom:
			if rule.Atom.ComparisonOperator != rulesv1beta3.ComparisonOperator_COMPARISON_OPERATOR_CONTAINED_WITHIN &&
				rule.Atom.ComparisonOperator != rulesv1beta3.ComparisonOperator_COMPARISON_OPERATOR_CONTAINS &&
				rule.Atom.ComparisonOperator != rulesv1beta3.ComparisonOperator_COMPARISON_OPERATOR_STARTS_WITH &&
				rule.Atom.ComparisonOperator != rulesv1beta3.ComparisonOperator_COMPARISON_OPERATOR_ENDS_WITH {
				ruleStrFmt = "!(%s)"
			}
		}
		return fmt.Sprintf(ruleStrFmt, g.translateRule(v.Not, staticContext, usedVariables, usedStrings, usedSlices))
	case *rulesv1beta3.Rule_LogicalExpression:
		operator := " && "
		switch v.LogicalExpression.GetLogicalOperator() {
		case rulesv1beta3.LogicalOperator_LOGICAL_OPERATOR_OR:
			operator = " || "
		}
		var result []string
		for _, rule := range v.LogicalExpression.Rules {
			ruleStrFmt := "%s"
			// If child is a nested logical expression, wrap in parens
			if l, nested := rule.Rule.(*rulesv1beta3.Rule_LogicalExpression); nested {
				// Exception: if current level is || and child is &&, we don't need parens
				// This technically depends on dev preference, we should pick one version and stick with it for canonicity
				if !(v.LogicalExpression.LogicalOperator == rulesv1beta3.LogicalOperator_LOGICAL_OPERATOR_OR && l.LogicalExpression.LogicalOperator == rulesv1beta3.LogicalOperator_LOGICAL_OPERATOR_AND) {
					ruleStrFmt = "(%s)"
				}
			}
			result = append(result, fmt.Sprintf(ruleStrFmt, g.translateRule(rule, staticContext, usedVariables, usedStrings, usedSlices)))
		}
		return strings.Join(result, operator)
	default:
		panic(fmt.Errorf("unsupported type of rule %+v", v))
	}
}

func (g *goGenerator) translateProtoFieldValue(parent protoreflect.Message, f protoreflect.FieldDescriptor, val protoreflect.Value) string {
	if f.IsMap() {
		// For map fields, f.Kind() is MessageKind but we need to handle key and value descriptors separately
		// TODO: Add support for protobuf type values
		assert.NotEqual(f.MapValue().Kind(), protoreflect.MessageKind, "unsupported protobuf type for map values")
		var lines []string
		res := fmt.Sprintf("map[%s]%s{", f.MapKey().Kind().String(), f.MapValue().Kind().String())
		val.Map().Range(func(mk protoreflect.MapKey, mv protoreflect.Value) bool {
			lines = append(lines, fmt.Sprintf("\"%s\": %s",
				mk.String(),
				g.translateProtoFieldValue(parent, f.MapValue(), mv)))
			return true
		})
		if len(lines) > 1 {
			slices.Sort(lines)
			res += "\n"
			res += strings.Join(lines, ",\n")
			res += ",\n}"
		} else {
			res += lines[0]
			res += "}"
		}
		return res
	} else if f.IsList() {
		// For list fields, f.Kind() is the type of each item (not necessarily MessageKind)
		lVal := val.List()
		var lines []string
		res := fmt.Sprintf("[]%s{", f.Kind().String())
		// For repeated messages, literal type can't just be stringified
		if f.Kind() == protoreflect.MessageKind {
			protoType := g.getProtoImportFromValue(parent, lVal.NewElement().Message()) // Not sure if this is the best way to get message type for list
			res = fmt.Sprintf("[]*%s.%s{", protoType.PackageAlias, protoType.Type)
		}
		for i := range lVal.Len() {
			lines = append(lines, g.translateProtoNonRepeatedValue(parent, f.Kind(), lVal.Get(i), true))
		}
		// Multiline formatting
		if len(lines) > 1 || (len(lines) == 1 && strings.Contains(lines[0], "\n")) {
			res += "\n"
			res += strings.Join(lines, ",\n")
			res += ",\n}"
		} else {
			res += strings.Join(lines, "")
			res += "}"
		}
		return res
	} else {
		return g.translateProtoNonRepeatedValue(parent, f.Kind(), val, false)
	}
}

func (g *goGenerator) translateProtoNonRepeatedValue(parent protoreflect.Message, kind protoreflect.Kind, val protoreflect.Value, omitLiteralType bool) string {
	switch kind {
	case protoreflect.EnumKind:
		// TODO: Actually handle enums, right now they're just numbers
		return val.String()
	case protoreflect.StringKind:
		return g.toQuoted(val.String())
	case protoreflect.BoolKind:
		return val.String()
	case protoreflect.BytesKind:
		panic("Don't know how to take bytes, try nibbles")
	case protoreflect.FloatKind:
		fallthrough
	case protoreflect.DoubleKind:
		fallthrough
	case protoreflect.Int64Kind:
		fallthrough
	case protoreflect.Int32Kind:
		fallthrough
	case protoreflect.Uint64Kind:
		fallthrough
	case protoreflect.Uint32Kind:
		// Don't need to do anything special for numerics
		return val.String()
	case protoreflect.MessageKind:
		// TODO - Maps are a special thing - do they work here?
		return g.translateProtoValue(parent, val.Message(), omitLiteralType)
	default:
		panic(fmt.Errorf("unsupported proto value type: %v", kind))
	}
}

func (g *goGenerator) translateAnyValue(val *anypb.Any, protoType *ProtoImport) string {
	msg, err := anypb.UnmarshalNew(val, proto.UnmarshalOptions{Resolver: g.TypeRegistry})
	if err != nil {
		panic(errors.Wrapf(err, "%s", val.TypeUrl))
	}
	if protoType == nil {
		// TODO we may need more special casing here for primitive types.
		// This feels like horrific syntax, but I needed this because
		// Int64 was somehow serializing to "1" instead of 1, and typechecking
		// doesn't seem to work since `UnmarshalNew` returns a `dynamicpb.Message` which doesn't work with go's type casing.
		if val.MessageIs((*wrapperspb.Int64Value)(nil)) {
			var i64 wrapperspb.Int64Value
			try.To(val.UnmarshalTo(&i64))
			return strconv.FormatInt(i64.Value, 10)
		}
		if val.MessageIs((*wrapperspb.StringValue)(nil)) {
			var s wrapperspb.StringValue
			try.To(val.UnmarshalTo(&s))
			return g.toQuoted(s.Value)
		}
		return string(try.To1(protojson.Marshal(msg)))
	}
	return g.translateProtoValue(nil, msg.ProtoReflect(), false)
}

func (g *goGenerator) translateProtoValue(parent protoreflect.Message, val protoreflect.Message, omitLiteralType bool) string {
	protoType := g.getProtoImportFromValue(parent, val)
	var lines []string
	val.Range(func(fd protoreflect.FieldDescriptor, fv protoreflect.Value) bool {
		lines = append(lines, fmt.Sprintf("%s: %s", strcase.ToCamel(fd.TextName()), g.translateProtoFieldValue(val, fd, fv)))
		return true
	})
	literalType := ""
	if !omitLiteralType {
		if protoType.PackageAlias == "" {
			literalType = fmt.Sprintf("&%s", protoType.Type)
		} else {
			literalType = fmt.Sprintf("&%s.%s", protoType.PackageAlias, protoType.Type)
		}
	}
	if len(lines) > 1 || (len(lines) == 1 && strings.Contains(lines[0], "\n")) {
		slices.Sort(lines)
		// Replace this with interface pointing stuff
		return fmt.Sprintf("%s{\n%s,\n}", literalType, strings.Join(lines, ",\n"))
	} else {
		return fmt.Sprintf("%s{%s}", literalType, strings.Join(lines, ""))
	}
}

// Takes a string and returns a double-quoted literal with applicable internal characters escaped, etc.
// For strings with newlines, returns a raw string literal instead.
// TODO - this type of thing might be a lot simpler with the AST library and the Printer
func (g *goGenerator) toQuoted(s string) string {
	if strings.Count(s, "\n") > 0 {
		return fmt.Sprintf("`%s`", s)
	}
	// Quote automatically handles escaping, etc.
	return strconv.Quote(s)
}

// Handles getting import & type literal information for both top-level and nested messages.
// TODO: Consider moving logic into UnpackProtoType directly which is shared with TS codegen as well
// TODO: This can definitely be cached, and doesn't need values, just descriptors
func (g *goGenerator) getProtoImportFromValue(parent protoreflect.Message, val protoreflect.Message) *ProtoImport {
	// Try finding in type registry
	_, err := g.TypeRegistry.FindMessageByName((val.Descriptor().FullName()))
	if errors.Is(err, protoregistry.NotFound) {
		// If there's no parent, this can't be a nested message, which is a problem
		assert.NotEqual(parent, nil, "missing in type registry with no parent")
		// Try finding in parent's nested message definitions
		nestedMsgDesc := parent.Descriptor().Messages().ByName(val.Descriptor().Name())
		if nestedMsgDesc == nil {
			panic(fmt.Sprintf("unable to find message type %s", val.Descriptor().FullName()))
		}
		parentProtoType := g.getProtoImportFromValue(nil, parent)
		return &ProtoImport{
			ImportPath:   parentProtoType.ImportPath,
			PackageAlias: parentProtoType.PackageAlias,
			Type:         fmt.Sprintf("%s_%s", parentProtoType.Type, string(nestedMsgDesc.Name())),
		}
	} else if err != nil {
		panic(errors.Wrap(err, "unknown error while checking type registry"))
	} else {
		// Found in type registry (i.e. top-level message)
		return UnpackProtoType(g.moduleRoot, g.lekkoPath, string(val.Descriptor().FullName()))
	}
}

// TODO: Generify
// Get all unique possible return values of a config
func (g *goGenerator) getStringRetValues(f *featurev1beta1.Feature) []string {
	if f.Type != featurev1beta1.FeatureType_FEATURE_TYPE_STRING {
		return []string{}
	}
	valSet := make(map[string]bool)
	valSet[g.translateAnyValue(f.Tree.Default, nil)] = true
	for _, constraint := range f.Tree.Constraints {
		ret := g.translateAnyValue(constraint.Value, nil)
		valSet[ret] = true
	}
	var rets []string
	for val := range valSet {
		rets = append(rets, val)
	}
	sort.Strings(rets)
	return rets
}

func (g *goGenerator) genClientFile(moduleRoot string) (err error) {
	defer err2.Handle(&err)
	// Template for generated client initialization code.
	// TODO: consider an ergonomic way of letting caller know that static fallback will be used due to failed remote init
	// TODO: use the retry-provider to keep attempting to connect
	// TODO: log that we didn't connect
	// TODO: change "not implemented" to like "Not connected to Lekko Server, using fallback"
	const clientTemplateBody = `// Generated by Lekko. DO NOT EDIT.
package lekko

import (
	"context"
	"errors"
	"os"

	client "github.com/lekkodev/go-sdk/client"
	{{- range $.Namespaces}}
	{{nsToImport .}}{{end}}
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
)

type LekkoClient struct {
	{{- range $.Namespaces}}
	{{nsToClientFieldType .}}{{end}}
	Close client.CloseFunc
}

// Initializes the Lekko SDK client.
// For remote configs to be fetched correctly, the LEKKO_API_KEY, LEKKO_REPOSITORY_OWNER, and LEKKO_REPOSITORY_NAME env variables are required.
// If these values are missing or if there are any connection errors, the static fallbacks will be used.
func NewLekkoClient(ctx context.Context, opts ...client.ProviderOption) *LekkoClient {
	apiKey := os.Getenv("LEKKO_API_KEY")
	repoOwner := "{{$.RepositoryOwner}}"
	repoName := "{{$.RepositoryName}}"
	opts = append(opts, client.WithAPIKey(apiKey))
	provider, err := client.CachedAPIProvider(ctx, &client.RepositoryKey{
		OwnerName: repoOwner,
		RepoName: repoName,
	}, opts...)
	if err != nil {
		provider = &noOpProvider{}
	}
	cli, close := client.NewClient(provider)
	return &LekkoClient{
		{{- range $.Namespaces}}
		{{nsToClientField .}},{{end}}
		Close: close,
	}
}

type noOpProvider struct {}

func (p *noOpProvider) GetBool(ctx context.Context, key string, namespace string) (bool, error) {
	return false, errors.New("not implemented")
}
func (p *noOpProvider) GetInt(ctx context.Context, key string, namespace string) (int64, error) {
	return 0, errors.New("not implemented")
}
func (p *noOpProvider) GetFloat(ctx context.Context, key string, namespace string) (float64, error) {
	return 0, errors.New("not implemented")
}
func (p *noOpProvider) GetString(ctx context.Context, key string, namespace string) (string, error) {
	return "", errors.New("not implemented")
}
func (p *noOpProvider) GetProto(ctx context.Context, key string, namespace string, result proto.Message) error {
	return errors.New("not implemented")
}
func (p *noOpProvider) GetJSON(ctx context.Context, key string, namespace string, result interface{}) error {
	return errors.New("not implemented")
}
func (p *noOpProvider) GetAny(ctx context.Context, key string, namespace string) (protoreflect.ProtoMessage, error) {
	return nil, errors.New("not implemented")
}
func (p *noOpProvider) Close(ctx context.Context) error {
	return nil
}
`

	// TODO: Refactor to just pass dotlekko when constructing generator
	dot := try.To1(dotlekko.ReadDotLekko(""))
	repoOwner, repoName := dot.GetRepoInfo()

	clientTemplateData := struct {
		Namespaces      []string
		RepositoryOwner string
		RepositoryName  string
	}{
		[]string{},
		repoOwner,
		repoName,
	}
	clientTemplateFuncs := map[string]any{
		"nsToImport": func(ns string) string {
			return fmt.Sprintf("lekko%s \"%s/%s/%s\"", ns, moduleRoot, g.lekkoPath, ns)
		},
		"nsToClientFieldType": func(ns string) string {
			return fmt.Sprintf("%s *lekko%s.LekkoClient", strcase.ToCamel(ns), ns)
		},
		"nsToClientField": func(ns string) string {
			return fmt.Sprintf("%s: &lekko%s.LekkoClient{Client: cli}", strcase.ToCamel(ns), ns)
		},
	}
	// Walk through lekko/ directory to find namespaces
	// We walk through dir instead of just using the namespace from above because shared client init code should include every namespace
	clientTemplateData.Namespaces = try.To1(native.ListNamespaces(g.outputPath, native.LangGo))
	var contents bytes.Buffer
	templ := template.Must(template.New("client").Funcs(clientTemplateFuncs).Parse(clientTemplateBody))
	if err := templ.Execute(&contents, clientTemplateData); err != nil {
		return errors.Wrap(err, "generate client initialization code: template exec")
	}
	formatted, err := format.Source(contents.Bytes())
	if err != nil {
		return errors.Wrap(err, "generation client initialization code: format")
	}
	f, err := os.Create(path.Join(g.outputPath, "client_gen.go"))
	if err != nil {
		return errors.Wrap(err, "generate client initialization code: create file")
	}
	if _, err := f.Write(formatted); err != nil {
		return errors.Wrap(err, fmt.Sprintf("write formatted contents to %s", f.Name()))
	}
	return nil
}

func DescriptorToStructDeclaration(d protoreflect.MessageDescriptor) string {
	var result string
	result += fmt.Sprintf("type %s struct {\n", d.Name()) // TODO
	fields := d.Fields()
	for i := 0; i < fields.Len(); i++ {
		field := fields.Get(i)
		fieldName := strcase.ToCamel(string(field.Name()))
		goType := FieldDescriptorToGoTypeString(field)
		result += fmt.Sprintf("\t%s %s;\n", fieldName, goType)
	}
	result += "}\n"
	return result
}

func FieldDescriptorToGoTypeString(field protoreflect.FieldDescriptor) string {
	var goType string
	switch field.Kind() {
	case protoreflect.BoolKind:
		goType = "bool"
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:
		goType = "int32"
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
		goType = "int64"
	case protoreflect.Uint32Kind, protoreflect.Fixed32Kind:
		goType = "uint32"
	case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
		goType = "uint64"
	case protoreflect.FloatKind:
		goType = "float32"
	case protoreflect.DoubleKind:
		goType = "float64"
	case protoreflect.StringKind:
		goType = "string"
	case protoreflect.BytesKind:
		goType = "[]byte"
	case protoreflect.MessageKind, protoreflect.GroupKind:
		if field.IsMap() {
			keyField := field.MapKey()
			valueField := field.MapValue()
			goType = "map[" + FieldDescriptorToGoTypeString(keyField) + "]" + FieldDescriptorToGoTypeString(valueField)
		} else if field.Message().FullName() == "google.protobuf.Duration" {
			goType = "*durationpb.Duration"
		} else {
			goType = "*" + string(field.Message().Name())
		}
	case protoreflect.EnumKind:
		goType = string(field.Enum().Name())
	default:
		goType = "interface{}"
	}
	return goType
}
