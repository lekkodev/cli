"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformer = exports.twoWaySync = void 0;
const tslib_1 = require("tslib");
const assert_1 = tslib_1.__importDefault(require("assert"));
const os_1 = tslib_1.__importDefault(require("os"));
const path_1 = tslib_1.__importDefault(require("path"));
const child_process_1 = require("child_process");
const typescript_1 = tslib_1.__importDefault(require("typescript"));
const helpers_1 = require("./helpers");
const ts_to_lekko_1 = require("./ts-to-lekko");
const patch_1 = require("./patch");
const emit_env_vars_1 = require("./emit-env-vars");
const lodash_kebabcase_1 = tslib_1.__importDefault(require("lodash.kebabcase"));
const CONFIG_IDENTIFIER_NAME = "_config";
const CTX_IDENTIFIER_NAME = "_ctx";
function getRepoPathFromCLI() {
    const repoCmd = (0, child_process_1.spawnSync)("lekko", ["repo", "path"], { encoding: "utf-8" });
    if (repoCmd.error !== undefined || repoCmd.status !== 0) {
        return path_1.default.join(os_1.default.homedir(), "Library/Application Support/Lekko/Config Repositories/default/");
    }
    return repoCmd.stdout.trim();
}
/**
 * Generate Proto and Starlark from Typescript and then regenerate Typescript back
 */
function twoWaySync(program, pluginConfig, extras) {
    var _a;
    const { configSrcPath = "", target = "node", repoPath = "" } = pluginConfig;
    const resolvedConfigSrcPath = path_1.default.resolve(configSrcPath);
    const lekkoSourceFiles = program
        .getSourceFiles()
        .filter((sourceFile) => (0, helpers_1.isLekkoConfigFile)(sourceFile.fileName, resolvedConfigSrcPath));
    const tsInstance = (_a = extras === null || extras === void 0 ? void 0 : extras.ts) !== null && _a !== void 0 ? _a : typescript_1.default;
    const checker = program.getTypeChecker();
    const protoFileBuilder = { messages: {}, enums: {} };
    const configs = [];
    function visitSourceFile(sourceFile) {
        const namespace = path_1.default.basename(sourceFile.fileName, path_1.default.extname(sourceFile.fileName));
        function visit(node) {
            if (tsInstance.isSourceFile(node)) {
                const match = node.fileName.match(helpers_1.LEKKO_FILENAME_REGEX);
                if (match) {
                    tsInstance.visitEachChild(node, visit, undefined);
                    try {
                        // The following are per-file operations
                        (0, ts_to_lekko_1.checkCLIDeps)();
                        // TODO this needs to be a no-op if the tools aren't there
                        (0, ts_to_lekko_1.genProtoFile)(node, repoPath, protoFileBuilder);
                        configs.forEach((config) => (0, ts_to_lekko_1.genStarlark)(repoPath, namespace, config));
                        const repoCmd = (0, child_process_1.spawnSync)("lekko", [
                            "exp",
                            "gen",
                            "ts",
                            "-n",
                            namespace,
                            "-o",
                            resolvedConfigSrcPath,
                        ], {
                            encoding: "utf-8",
                        });
                        if (repoCmd.error !== undefined || repoCmd.status !== 0) {
                            console.log(`[@lekko/ts-transformer] failed to regenerate ts`);
                        }
                        const prettierCmd = (0, child_process_1.spawnSync)("npx", [
                            "prettier",
                            "-w",
                            sourceFile.fileName,
                        ]);
                        if (prettierCmd.error !== undefined || prettierCmd.status !== 0) {
                            console.log(`[@lekko/ts-transformer] failed to run prettier`);
                        }
                    }
                    catch (_a) {
                        console.log("[@lekko/ts-transformer] CLI tools missing, skipping proto and starlark generation.");
                    }
                }
            }
            else if (tsInstance.isFunctionDeclaration(node)) {
                const { checkedNode, configName, returnType } = checkConfigFunctionDeclaration(checker, target, node);
                // Apply changes to config repo
                const configJSON = (0, ts_to_lekko_1.functionToConfigJSON)(checkedNode, checker, namespace, configName, returnType);
                configs.push(configJSON);
            }
            else if (tsInstance.isInterfaceDeclaration(node)) {
                (0, ts_to_lekko_1.interfaceToProto)(node, checker, protoFileBuilder);
            }
            return undefined;
        }
        typescript_1.default.visitNode(sourceFile, visit);
    }
    lekkoSourceFiles.forEach((sourceFile) => {
        visitSourceFile(sourceFile);
    });
}
exports.twoWaySync = twoWaySync;
function transformProgram(program, host, pluginConfig, extras) {
    var _a;
    pluginConfig = pluginConfig !== null && pluginConfig !== void 0 ? pluginConfig : {};
    pluginConfig.repoPath = getRepoPathFromCLI();
    const { repoPath = "", configSrcPath = "./src/lekko", emitEnv = true, target = "node", } = pluginConfig !== null && pluginConfig !== void 0 ? pluginConfig : {};
    const resolvedConfigSrcPath = path_1.default.resolve(configSrcPath);
    const compilerOptions = program.getCompilerOptions();
    const tsInstance = (_a = extras === null || extras === void 0 ? void 0 : extras.ts) !== null && _a !== void 0 ? _a : typescript_1.default;
    const rootFileNames = program
        .getRootFileNames()
        .map(tsInstance.normalizePath);
    const compilerHost = host !== null && host !== void 0 ? host : tsInstance.createCompilerHost(compilerOptions, true);
    // Patch host to make the generated and transformed source files available
    const sfCache = new Map();
    (0, patch_1.patchCompilerHost)(compilerHost, sfCache);
    // We run our source transformer on existing source files first.
    // As a side effect, this pushes configs generated from Lekko-TS files to the
    // local config repo (starlark + protos).
    const lekkoSourceFiles = program
        .getSourceFiles()
        .filter((sourceFile) => (0, helpers_1.isLekkoConfigFile)(sourceFile.fileName, resolvedConfigSrcPath));
    const transformerExtras = {
        ts: tsInstance,
        library: "typescript",
        addDiagnostic: () => 0,
        removeDiagnostic: () => { },
        diagnostics: [],
    };
    twoWaySync(program, pluginConfig, transformerExtras);
    let updatedProgram = tsInstance.createProgram([...rootFileNames, ...sfCache.keys()], compilerOptions, compilerHost);
    const transformedSources = tsInstance.transform(lekkoSourceFiles, [
        // TODO: restructure source transformer
        transformer(updatedProgram, pluginConfig, transformerExtras),
    ], compilerOptions).transformed;
    // Then, we need to generate proto bindings and add the generated + transformed source files to the program
    const printer = tsInstance.createPrinter();
    transformedSources.forEach((sourceFile) => {
        const namespace = path_1.default.basename(sourceFile.fileName, path_1.default.extname(sourceFile.fileName));
        sfCache.set(sourceFile.fileName, tsInstance.createSourceFile(sourceFile.fileName, printer.printFile(sourceFile), sourceFile.languageVersion));
        try {
            const genIter = (0, ts_to_lekko_1.genProtoBindings)(repoPath, configSrcPath, namespace);
            genIter.next();
            const generated = genIter.next();
            if (!generated.done) {
                Object.entries(generated.value).forEach(([fileName, contents]) => {
                    sfCache.set(path_1.default.join(resolvedConfigSrcPath, fileName), tsInstance.createSourceFile(path_1.default.join(resolvedConfigSrcPath, fileName), contents, typescript_1.default.ScriptTarget.ES2017));
                });
                // Trigger cleanup (TODO: probably doesn't need to be a generator)
                genIter.next();
            }
        }
        catch (e) {
            console.warn("Failed to generate proto bindings, continuing");
        }
    });
    // We need to add these bindings to the program
    updatedProgram = tsInstance.createProgram([...rootFileNames, ...sfCache.keys()], compilerOptions, compilerHost);
    // Patch updated program to cleanly handle diagnostics and such
    (0, patch_1.patchProgram)(updatedProgram);
    // Emit env vars
    if (emitEnv) {
        try {
            (0, emit_env_vars_1.emitEnvVars)(target, typeof emitEnv === "string"
                ? emitEnv
                : // NextJS conventions are to use .env.local by default for local work
                    target === "next"
                        ? ".env.local"
                        : ".env");
        }
        catch (e) {
            console.warn("[@lekko/ts-transformer]", e.message);
        }
    }
    return updatedProgram;
}
exports.default = transformProgram;
function checkConfigFunctionDeclaration(checker, target, node) {
    const sig = checker.getSignatureFromDeclaration(node);
    (0, assert_1.default)(sig);
    if (!(0, helpers_1.isCheckedFunctionDeclaration)(node)) {
        throw new Error("Invalid function declaration: missing name or body");
    }
    // Check name
    const functionName = node.name.getFullText().trim();
    if (!/^\s*get[A-Z][A-Za-z]*$/.test(functionName)) {
        throw new Error(`Unparsable function name "${functionName}": config function names must start with "get"`);
    }
    const configName = (0, lodash_kebabcase_1.default)(functionName.substring(3));
    // Check return type
    const isAsync = typescript_1.default.isAsyncFunction(node);
    if (target === "node" && !isAsync) {
        throw new Error("Config function must be async if target is node");
    }
    else if (isAsync) {
        throw new Error(`Config function must not be async if target is ${target}`);
    }
    const returnType = target === "node"
        ? checker.getPromisedTypeOfPromise(sig.getReturnType())
        : sig.getReturnType();
    (0, assert_1.default)(returnType, "Unable to parse return type");
    return { checkedNode: node, configName, returnType };
}
function transformer(program, pluginConfig, extras) {
    var _a;
    const tsInstance = (_a = extras === null || extras === void 0 ? void 0 : extras.ts) !== null && _a !== void 0 ? _a : typescript_1.default;
    const { target = "node" } = pluginConfig !== null && pluginConfig !== void 0 ? pluginConfig : {};
    const checker = program.getTypeChecker();
    return (context) => {
        const { factory } = context;
        let hasImportProto = false;
        function transformLocalToRemote(node, namespace, configName, returnType, 
        // We work with parsing the JSON representations of config protos for now
        // It's probably slower but less dependencies to worry about and still "typed"
        config) {
            let getter = undefined;
            if (returnType.flags & tsInstance.TypeFlags.String) {
                getter = "getString";
            }
            else if (returnType.flags & tsInstance.TypeFlags.Number) {
                // TODO use config to handle float vs int
                getter = "getFloat";
            }
            else if (returnType.flags & tsInstance.TypeFlags.Boolean) {
                getter = "getBool";
            }
            else if (returnType.flags & tsInstance.TypeFlags.Object) {
                if (config.type === "FEATURE_TYPE_JSON") {
                    getter = "getJSON";
                }
                else if (config.type === "FEATURE_TYPE_PROTO") {
                    getter = "getProto";
                }
                else {
                    throw new Error("Error");
                }
            }
            if (getter === undefined) {
                throw new Error(`Unsupported TypeScript type: ${returnType.flags} - ${program === null || program === void 0 ? void 0 : program.getTypeChecker().typeToString(returnType)}`);
            }
            if (getter === "getProto") {
                const protoTypeParts = config.tree.default["@type"].split(".");
                const protoType = protoTypeParts[protoTypeParts.length - 1];
                const maybeProtoImport = [];
                if (!hasImportProto) {
                    maybeProtoImport.push(factory.createImportDeclaration(undefined, factory.createImportClause(false, undefined, factory.createNamespaceImport(factory.createIdentifier("lekko_pb"))), factory.createStringLiteral(`./gen/${namespace}/config/v1beta1/${namespace}_pb.ts`), undefined));
                    hasImportProto = true;
                }
                return maybeProtoImport.concat([
                    factory.updateFunctionDeclaration(node, node.modifiers, node.asteriskToken, node.name, node.typeParameters, [
                        factory.createParameterDeclaration(undefined, undefined, factory.createIdentifier(CTX_IDENTIFIER_NAME), undefined, undefined, undefined),
                    ].concat(
                    // For FE, require client as second parameter
                    target !== "node"
                        ? [
                            factory.createParameterDeclaration(undefined, undefined, factory.createIdentifier("client"), undefined, undefined, undefined),
                        ]
                        : []), node.type, prependParamVars(node, CTX_IDENTIFIER_NAME, wrapTryCatch(factory.createBlock([
                        factory.createVariableStatement(undefined, factory.createVariableDeclarationList([
                            factory.createVariableDeclaration(CONFIG_IDENTIFIER_NAME, undefined, undefined, factory.createNewExpression(factory.createPropertyAccessExpression(factory.createIdentifier("lekko_pb"), factory.createIdentifier(protoType)), undefined, [])),
                        ], tsInstance.NodeFlags.Const)),
                        factory.createExpressionStatement(factory.createCallExpression(factory.createPropertyAccessExpression(factory.createIdentifier(CONFIG_IDENTIFIER_NAME), factory.createIdentifier("fromBinary")), undefined, [
                            factory.createPropertyAccessExpression(factory.createCallExpression(factory.createPropertyAccessExpression(target !== "node"
                                ? factory.createIdentifier("client")
                                : factory.createParenthesizedExpression(factory.createAwaitExpression(factory.createCallExpression(factory.createPropertyAccessExpression(factory.createIdentifier("lekko"), factory.createIdentifier("getClient")), undefined, []))), factory.createIdentifier("getProto")), undefined, [
                                factory.createStringLiteral(namespace),
                                factory.createStringLiteral(configName),
                                factory.createCallExpression(factory.createPropertyAccessExpression(factory.createPropertyAccessExpression(factory.createIdentifier("lekko"), factory.createIdentifier("ClientContext")), factory.createIdentifier("fromJSON")), undefined, [
                                    factory.createIdentifier(CTX_IDENTIFIER_NAME),
                                ]),
                            ]), factory.createIdentifier("value")),
                        ])),
                        factory.createReturnStatement(factory.createIdentifier(CONFIG_IDENTIFIER_NAME)),
                    ], true), node.body))),
                    // For use by FE SDKs to be able to identify configs
                    factory.createExpressionStatement(factory.createBinaryExpression(factory.createPropertyAccessExpression(node.name, factory.createIdentifier("_namespaceName")), factory.createToken(tsInstance.SyntaxKind.EqualsToken), factory.createStringLiteral(namespace))),
                    factory.createExpressionStatement(factory.createBinaryExpression(factory.createPropertyAccessExpression(node.name, factory.createIdentifier("_configName")), factory.createToken(tsInstance.SyntaxKind.EqualsToken), factory.createStringLiteral(configName))),
                    factory.createExpressionStatement(factory.createBinaryExpression(factory.createPropertyAccessExpression(node.name, factory.createIdentifier("_evaluationType")), factory.createToken(tsInstance.SyntaxKind.EqualsToken), factory.createStringLiteral(config.type))),
                ]);
            }
            return [
                factory.updateFunctionDeclaration(node, node.modifiers, node.asteriskToken, node.name, node.typeParameters, [
                    factory.createParameterDeclaration(undefined, undefined, CTX_IDENTIFIER_NAME, undefined, undefined, undefined),
                ].concat(
                // For FE, require client as second parameter
                target !== "node"
                    ? [
                        factory.createParameterDeclaration(undefined, undefined, factory.createIdentifier("client"), undefined, undefined, undefined),
                    ]
                    : []), node.type, prependParamVars(node, CTX_IDENTIFIER_NAME, wrapTryCatch(factory.createBlock([
                    target !== "node"
                        ? factory.createEmptyStatement()
                        : factory.createExpressionStatement(factory.createAwaitExpression(factory.createCallExpression(
                        // TODO -- this should be top level.. but ts module build shit is horrible
                        factory.createPropertyAccessExpression(factory.createIdentifier("lekko"), factory.createIdentifier("setupClient")), undefined, []))),
                    factory.createReturnStatement(factory.createCallExpression(factory.createPropertyAccessExpression(target !== "node"
                        ? factory.createIdentifier("client")
                        : factory.createParenthesizedExpression(factory.createAwaitExpression(factory.createCallExpression(factory.createPropertyAccessExpression(factory.createIdentifier("lekko"), factory.createIdentifier("getClient")), undefined, []))), factory.createIdentifier(getter)), undefined, [
                        factory.createStringLiteral(namespace),
                        factory.createStringLiteral(configName),
                        factory.createCallExpression(factory.createPropertyAccessExpression(factory.createPropertyAccessExpression(factory.createIdentifier("lekko"), factory.createIdentifier("ClientContext")), factory.createIdentifier("fromJSON")), undefined, [factory.createIdentifier(CTX_IDENTIFIER_NAME)]),
                    ])),
                ], true), node.body))),
                factory.createExpressionStatement(factory.createBinaryExpression(factory.createPropertyAccessExpression(node.name, factory.createIdentifier("_namespaceName")), factory.createToken(tsInstance.SyntaxKind.EqualsToken), factory.createStringLiteral(namespace))),
                factory.createExpressionStatement(factory.createBinaryExpression(factory.createPropertyAccessExpression(node.name, factory.createIdentifier("_configName")), factory.createToken(tsInstance.SyntaxKind.EqualsToken), factory.createStringLiteral(configName))),
                factory.createExpressionStatement(factory.createBinaryExpression(factory.createPropertyAccessExpression(node.name, factory.createIdentifier("_evaluationType")), factory.createToken(tsInstance.SyntaxKind.EqualsToken), factory.createStringLiteral(config.type))),
            ];
        }
        // Prepend the given body with a variable assignment to make the function's parameters available
        // in the body. No-op if there was no parameter to start.
        // i.e. adds `const { env } = ctx` to start
        function prependParamVars(fd, newParamName, body) {
            var _a;
            // Get original first parameter to function
            const param = (_a = fd.parameters[0]) === null || _a === void 0 ? void 0 : _a.getChildAt(0); // GetChild for discarding type info
            if (param === undefined) {
                return body;
            }
            return factory.createBlock([
                factory.createVariableStatement(undefined, factory.createVariableDeclarationList([
                    factory.createVariableDeclaration(
                    // This is technically probably not a good way to destructure
                    param.getFullText(), undefined, undefined, factory.createIdentifier(newParamName)),
                ])),
                ...body.statements,
            ]);
        }
        // Use for handling static fallback
        function wrapTryCatch(tryBlock, catchBlock) {
            return factory.createBlock([
                factory.createTryStatement(tryBlock, factory.createCatchClause(factory.createVariableDeclaration(factory.createIdentifier("e"), undefined, undefined, undefined), catchBlock), undefined),
            ]);
        }
        function addLekkoImports(sourceFile) {
            return factory.updateSourceFile(sourceFile, [
                factory.createImportDeclaration(undefined, factory.createImportClause(false, undefined, factory.createNamespaceImport(factory.createIdentifier("lekko"))), factory.createStringLiteral(target !== "node" ? "@lekko/js-sdk" : "@lekko/node-server-sdk"), undefined),
                ...sourceFile.statements,
            ]);
        }
        return (sourceFile) => {
            const namespace = path_1.default.basename(sourceFile.path, path_1.default.extname(sourceFile.path));
            function visit(node) {
                if (tsInstance.isSourceFile(node)) {
                    const match = node.fileName.match(helpers_1.LEKKO_FILENAME_REGEX);
                    if (match) {
                        let transformed = addLekkoImports(node);
                        transformed = tsInstance.visitEachChild(transformed, visit, context);
                        return transformed;
                    }
                    else {
                        return node;
                    }
                }
                else if (tsInstance.isFunctionDeclaration(node)) {
                    const { checkedNode, configName, returnType } = checkConfigFunctionDeclaration(checker, target, node);
                    const configJSON = (0, ts_to_lekko_1.functionToConfigJSON)(checkedNode, checker, namespace, configName, returnType);
                    // Transform local (static) to SDK client calls
                    return transformLocalToRemote(checkedNode, namespace, configName, returnType, configJSON);
                }
                return node;
            }
            const visited = tsInstance.visitNode(sourceFile, visit);
            return visited;
        };
    };
}
exports.transformer = transformer;
//# sourceMappingURL=transformer.js.map