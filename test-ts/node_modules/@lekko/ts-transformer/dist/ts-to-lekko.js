"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.genProtoBindings = exports.genProtoFile = exports.checkCLIDeps = exports.interfaceToProto = exports.genStarlark = exports.functionToConfigJSON = void 0;
const tslib_1 = require("tslib");
const assert_1 = tslib_1.__importDefault(require("assert"));
const child_process_1 = require("child_process");
const lodash_camelcase_1 = tslib_1.__importDefault(require("lodash.camelcase"));
const lodash_snakecase_1 = tslib_1.__importDefault(require("lodash.snakecase"));
const node_fs_1 = tslib_1.__importDefault(require("node:fs"));
const node_path_1 = tslib_1.__importDefault(require("node:path"));
const typescript_1 = tslib_1.__importDefault(require("typescript"));
//import { rimrafSync } from "rimraf";
const helpers_1 = require("./helpers");
const COMPARISON_TOKEN_TO_OPERATOR = {
    [typescript_1.default.SyntaxKind.EqualsEqualsEqualsToken]: "COMPARISON_OPERATOR_EQUALS",
    [typescript_1.default.SyntaxKind.LessThanToken]: "COMPARISON_OPERATOR_LESS_THAN",
    [typescript_1.default.SyntaxKind.LessThanEqualsToken]: "COMPARISON_OPERATOR_LESS_THAN_OR_EQUALS",
    [typescript_1.default.SyntaxKind.GreaterThanToken]: "COMPARISON_OPERATOR_GREATER_THAN",
    [typescript_1.default.SyntaxKind.GreaterThanEqualsToken]: "COMPARISON_OPERATOR_GREATER_THAN_OR_EQUALS",
    [typescript_1.default.SyntaxKind.ExclamationEqualsEqualsToken]: "COMPARISON_OPERATOR_NOT_EQUALS",
};
const LOGICAL_TOKEN_TO_OPERATOR = {
    [typescript_1.default.SyntaxKind.AmpersandAmpersandToken]: "LOGICAL_OPERATOR_AND",
    [typescript_1.default.SyntaxKind.BarBarToken]: "LOGICAL_OPERATOR_OR",
};
const EXPRESSION_NAME_TO_OPERATOR = {
    includes: "COMPARISON_OPERATOR_CONTAINS",
    startsWith: "COMPARISON_OPERATOR_STARTS_WITH",
    endsWith: "COMPARISON_OPERATOR_ENDS_WITH",
};
function exprToContextKey(expr) {
    switch (expr.kind) {
        case typescript_1.default.SyntaxKind.Identifier:
            return expr.getText();
        case typescript_1.default.SyntaxKind.PropertyAccessExpression:
            return expr.name.getText();
        default:
            throw new Error(`need to be able to handle: ${typescript_1.default.SyntaxKind[expr.kind]}`);
    }
}
function expressionToThing(expression) {
    switch (expression.kind) {
        case typescript_1.default.SyntaxKind.BinaryExpression: {
            const binaryExpr = expression;
            const tokenKind = binaryExpr.operatorToken.kind;
            if (tokenKind === typescript_1.default.SyntaxKind.ExclamationEqualsEqualsToken &&
                binaryExpr.right.getText() === "undefined") {
                return {
                    atom: {
                        contextKey: exprToContextKey(binaryExpr.left),
                        comparisonOperator: "COMPARISON_OPERATOR_PRESENT",
                    },
                };
            }
            else if (tokenKind in COMPARISON_TOKEN_TO_OPERATOR) {
                return {
                    atom: {
                        contextKey: exprToContextKey(binaryExpr.left),
                        comparisonValue: expressionToJsonValue(binaryExpr.right),
                        comparisonOperator: COMPARISON_TOKEN_TO_OPERATOR[tokenKind],
                    },
                };
            }
            else if (tokenKind in LOGICAL_TOKEN_TO_OPERATOR) {
                return {
                    logicalExpression: {
                        rules: [
                            expressionToThing(binaryExpr.left),
                            expressionToThing(binaryExpr.right),
                        ],
                        logicalOperator: LOGICAL_TOKEN_TO_OPERATOR[tokenKind],
                    },
                };
            }
            else {
                throw new Error(`Operator ${typescript_1.default.SyntaxKind[binaryExpr.operatorToken.kind]} is currently not supported`);
            }
        }
        case typescript_1.default.SyntaxKind.ParenthesizedExpression: {
            const expr = expression;
            return expressionToThing(expr.expression);
        }
        case typescript_1.default.SyntaxKind.CallExpression: {
            const callExpr = expression;
            const propertyAccessExpr = callExpr.expression;
            if (typescript_1.default.isPropertyAccessExpression(propertyAccessExpr)) {
                const expressionName = propertyAccessExpr.name
                    .text;
                const comparisonOperator = EXPRESSION_NAME_TO_OPERATOR[expressionName];
                if (comparisonOperator !== undefined) {
                    return {
                        atom: {
                            contextKey: exprToContextKey(propertyAccessExpr.expression),
                            comparisonValue: expressionToJsonValue(callExpr.arguments[0]),
                            comparisonOperator: comparisonOperator,
                        },
                    };
                }
            }
            throw new Error(`Call expression ${propertyAccessExpr.getText()} is currently not supported`);
        }
        // TODO other literal types
        default: {
            throw new Error(`need to be able to handle: ${typescript_1.default.SyntaxKind[expression.kind]}`);
        }
    }
}
function ifStatementToRule(ifStatement, namespace, returnType) {
    const block = ifStatement.thenStatement;
    if (block.statements.length != 1) {
        throw new Error(`Must only contain return statement: ${block.getFullText()}`);
    }
    const ret = [
        {
            rule: expressionToThing(ifStatement.expression),
            value: returnStatementToValue(block.statements[0], namespace, returnType),
        },
    ];
    if (ifStatement.elseStatement) {
        if (ifStatement.elseStatement.kind === typescript_1.default.SyntaxKind.IfStatement) {
            ret.push(...ifStatementToRule(ifStatement.elseStatement, namespace, returnType));
        }
        else {
            throw new Error(`invalid else statement: ${block.getFullText()}`);
        }
    }
    return ret;
}
function returnStatementToValue(returnNode, namespace, returnType) {
    const expression = returnNode.expression;
    (0, assert_1.default)(expression);
    return expressionToProtoValue(expression, namespace, returnType);
}
// HACK: Essential eval(), it's an easy way to handle string literals, etc.
function expressionToJsonValue(expression) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-implied-eval
    return Function(`return ${expression.getFullText()}`)();
}
function expressionToProtoValue(expression, namespace, protoType) {
    switch (expression.kind) {
        case typescript_1.default.SyntaxKind.FalseKeyword:
            return {
                "@type": "type.googleapis.com/google.protobuf.BoolValue",
                value: false,
            };
        case typescript_1.default.SyntaxKind.TrueKeyword:
            return {
                "@type": "type.googleapis.com/google.protobuf.BoolValue",
                value: true,
            };
        case typescript_1.default.SyntaxKind.StringLiteral:
            return {
                "@type": "type.googleapis.com/google.protobuf.StringValue",
                value: expressionToJsonValue(expression),
            };
        case typescript_1.default.SyntaxKind.NumericLiteral:
            return {
                "@type": "type.googleapis.com/google.protobuf.DoubleValue",
                value: new Number(expression.getText()).valueOf(),
            };
        case typescript_1.default.SyntaxKind.ObjectLiteralExpression:
            return Object.assign(Object.assign({}, expressionToJsonValue(expression)), { 
                // Relies on a proto message being defined that has the same name as used
                "@type": `type.googleapis.com/${namespace}.config.v1beta1.${protoType}` });
        default:
            throw new Error(`need to be able to handle: ${typescript_1.default.SyntaxKind[expression.kind]}`);
    }
}
function getLekkoType(returnType, checker) {
    if (returnType.flags & typescript_1.default.TypeFlags.Boolean) {
        return "FEATURE_TYPE_BOOL";
    }
    if (returnType.flags & typescript_1.default.TypeFlags.Number) {
        return "FEATURE_TYPE_FLOAT";
    }
    if (returnType.flags & typescript_1.default.TypeFlags.String) {
        return "FEATURE_TYPE_STRING";
    }
    if (returnType.flags & typescript_1.default.TypeFlags.Object) {
        return "FEATURE_TYPE_PROTO";
    }
    throw new Error(`Unsupported TypeScript type: ${returnType.flags} - ${checker.typeToString(returnType)}`);
}
/**
 * Creates a JSON representation of a Lekko config from a function declaration.
 */
function functionToConfigJSON(node, checker, namespace, configKey, returnType) {
    // TODO support nested interfaces
    const configType = getLekkoType(returnType, checker);
    let valueType;
    if ((0, helpers_1.isIntrinsicType)(returnType)) {
        // This is how we check for boolean/number/string
        valueType = returnType.intrinsicName;
    }
    else {
        valueType = checker.typeToString(returnType, undefined, typescript_1.default.TypeFormatFlags.None);
    }
    (0, assert_1.default)(node.body);
    let configTreeDefault;
    let configTreeConstraints;
    for (const [_, statement] of node.body.statements.entries()) {
        switch (statement.kind) {
            case typescript_1.default.SyntaxKind.IfStatement: {
                const ruleValPairs = ifStatementToRule(statement, namespace, valueType);
                if (configTreeConstraints === undefined) {
                    configTreeConstraints = [];
                }
                for (const { value, rule } of ruleValPairs) {
                    configTreeConstraints.push({
                        value: value,
                        ruleAstNew: rule,
                    });
                }
                break;
            }
            case typescript_1.default.SyntaxKind.ReturnStatement: {
                // TODO check that it's only 3
                // TODO refactor for all return types
                configTreeDefault = returnStatementToValue(statement, namespace, valueType);
                break;
            }
            default: {
                throw new Error(`Unable to handle: ${typescript_1.default.SyntaxKind[statement.kind]}`);
            }
        }
    }
    (0, assert_1.default)(configTreeDefault, "Missing default value, check for return statement");
    const config = {
        key: configKey,
        // TODO: Handle descriptions
        description: "",
        tree: {
            default: configTreeDefault,
            constraints: configTreeConstraints,
        },
        type: configType,
    };
    return config;
}
exports.functionToConfigJSON = functionToConfigJSON;
/**
 * Generates starlark files in local config repo based on function declarations.
 * Depends on the Lekko CLI.
 */
function genStarlark(repoPath, namespace, config) {
    const configJSON = JSON.stringify(config, null, 2);
    const jsonDir = node_path_1.default.join(repoPath, namespace, "gen", "json");
    node_fs_1.default.mkdirSync(jsonDir, { recursive: true });
    node_fs_1.default.writeFileSync(node_path_1.default.join(jsonDir, `${config.key}.json`), configJSON);
    const spawnReturns = (0, child_process_1.spawnSync)("lekko", ["exp", "gen", "starlark", "-n", namespace, "-c", config.key], {
        encoding: "utf-8",
        cwd: repoPath,
    });
    if (spawnReturns.error !== undefined || spawnReturns.status !== 0) {
        throw new Error(`Failed to generate starlark for ${config.key}: ${spawnReturns.stdout}${spawnReturns.stderr}`);
    }
}
exports.genStarlark = genStarlark;
/**
 * Mutates the proto builder based on the interface declaration node.
 */
function interfaceToProto(node, checker, builder) {
    const name = node.name.getText();
    const fields = node.members.map((member, idx) => {
        if (typescript_1.default.isPropertySignature(member)) {
            const propertyName = (0, lodash_snakecase_1.default)(member.name.getText());
            (0, assert_1.default)(member.type);
            const propertyType = checker.getTypeAtLocation(member.type);
            const protoType = getProtoTypeFromTypeScriptType(checker, propertyType, propertyName, name, builder);
            return `${protoType} ${propertyName} = ${idx + 1};`;
        }
        else {
            throw new Error(`Unsupported member type: ${typescript_1.default.SyntaxKind[member.kind]} - ${member.getFullText()}`);
        }
    });
    builder.messages[name] = fields;
}
exports.interfaceToProto = interfaceToProto;
function symbolToFields(node, typeChecker, name, builder) {
    if (node.members == undefined) {
        throw new Error(`Error: Programmer is incompetent.  Replace with ChatGPT.`);
    }
    return Array.from(node.members).map(([propertyName, symbol], idx) => {
        const propertyType = typeChecker.getTypeOfSymbol(symbol);
        const fieldName = (0, lodash_snakecase_1.default)(propertyName.toString());
        const protoType = getProtoTypeFromTypeScriptType(typeChecker, propertyType, fieldName, name, builder);
        return `${protoType} ${fieldName} = ${idx + 1};`;
    });
}
function getProtoTypeFromTypeScriptType(checker, type, propertyName, name, builder) {
    var _a;
    if (type.flags & typescript_1.default.TypeFlags.String) {
        return "string";
    }
    if (type.flags & typescript_1.default.TypeFlags.Number) {
        return "double";
    }
    // TODO: Int fields
    if (type.flags & typescript_1.default.TypeFlags.Boolean) {
        return "bool";
    }
    if (type.flags & typescript_1.default.TypeFlags.Union) {
        const unionType = type;
        // If optional or undefined and another type, handle - proto fields are all optional
        // But specifically for optional booleans, there are 3 types - true, false, and undefined
        if (unionType.types.length === 3) {
            if (unionType.types.some((t) => (0, helpers_1.isIntrinsicType)(t) && t.intrinsicName === "false") &&
                unionType.types.some((t) => (0, helpers_1.isIntrinsicType)(t) && t.intrinsicName === "true") &&
                unionType.types.some((t) => t.flags & typescript_1.default.TypeFlags.Undefined)) {
                return "bool";
            }
            else {
                throw new Error("Union types are currently not fully supported.");
            }
        }
        else if (unionType.types.length === 2) {
            let definedType;
            const [typeA, typeB] = unionType.types;
            if (typeA.flags & typescript_1.default.TypeFlags.Undefined) {
                definedType = typeB;
            }
            else if (typeB.flags & typescript_1.default.TypeFlags.Undefined) {
                definedType = typeA;
            }
            else {
                throw new Error("Union types are currently not fully supported.");
            }
            return getProtoTypeFromTypeScriptType(checker, definedType, propertyName, name, builder);
        }
        // If all the types are ObjectLiteral - do we want to use that type, or make an enum?  Do we want to do oneOf for the others?
        throw new Error("Union types are currently not fully supported.");
    }
    if (type.flags & typescript_1.default.TypeFlags.Object) {
        // Need to turn nested objects in interface to protos as well
        const camelCasePropertyName = (0, lodash_camelcase_1.default)(propertyName);
        const childName = name +
            camelCasePropertyName.charAt(0).toUpperCase() +
            camelCasePropertyName.slice(1);
        const symbol = type.getSymbol();
        (0, assert_1.default)(symbol);
        // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison
        if (symbol.escapedName === "Array") {
            const typeArgs = type.typeArguments;
            (0, assert_1.default)(typeArgs);
            const innerType = typeArgs[0];
            return ("repeated " +
                getProtoTypeFromTypeScriptType(checker, innerType, propertyName, name, builder));
            // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison
        }
        else if (symbol.escapedName === "Date") {
            return "int32"; // TODO dates are stupid
        }
        else {
            const symbol = type.getSymbol();
            (0, assert_1.default)(symbol);
            (_a = builder.messages)[childName] || (_a[childName] = []);
            builder.messages[childName].push(...symbolToFields(symbol, checker, childName, builder));
        }
        return childName;
    }
    throw new Error(`Unsupported TypeScript type: ${type.flags} - ${checker.typeToString(type)}`);
}
/**
 * Check for presence of lekko and buf CLIs. Also creates a default repo for now.
 * TODO: Add version range checks.
 */
function checkCLIDeps() {
    const lekkoCmd = (0, child_process_1.spawnSync)("lekko", ["--version"]);
    const bufCmd = (0, child_process_1.spawnSync)("buf", ["--version"]);
    if (lekkoCmd.error !== undefined ||
        lekkoCmd.status !== 0 ||
        bufCmd.error !== undefined ||
        bufCmd.status !== 0) {
        throw new Error("Lekko CLI could not be found. Install it with `brew tap lekkodev/lekko && brew install lekko` and make sure it's located on your PATH.");
    }
    const defaultInitCmd = (0, child_process_1.spawnSync)("lekko", ["repo", "init-default"], {
        encoding: "utf-8",
    });
    if (defaultInitCmd.error !== undefined || defaultInitCmd.status !== 0) {
        throw new Error("Failed to initialize default Lekko repo");
    }
}
exports.checkCLIDeps = checkCLIDeps;
function getProtoPath(repoPath, namespace) {
    return node_path_1.default.join(repoPath, "proto", namespace, "config", "v1beta1", `${namespace}.proto`);
}
/**
 * Generate .proto files in local config repo.
 * TODO: Switch to using proto fds when we want to add more advanced features
 * and be more error-proof instead of manually constructing file contents
 */
function genProtoFile(sourceFile, repoPath, builder) {
    // Nothing to write?
    if (Object.keys(builder.messages).length === 0) {
        return;
    }
    const namespace = node_path_1.default.basename(sourceFile.path, node_path_1.default.extname(sourceFile.path));
    const protoPath = getProtoPath(repoPath, namespace);
    let contents = `syntax = "proto3";\n\n`;
    contents += `package ${namespace}.config.v1beta1;\n\n`;
    Object.entries(builder.messages).forEach(([messageName, fields]) => {
        contents += `message ${messageName} {\n  ${fields.join("\n  ")}\n}\n\n`;
    });
    node_fs_1.default.mkdirSync(node_path_1.default.dirname(protoPath), { recursive: true });
    node_fs_1.default.writeFileSync(protoPath, contents);
    const formatCmd = (0, child_process_1.spawnSync)("buf", ["format", protoPath, "--write"], {
        encoding: "utf-8",
    });
    if (formatCmd.error !== undefined || formatCmd.status !== 0) {
        throw new Error("Failed to generate well-formed protobuf files.");
    }
}
exports.genProtoFile = genProtoFile;
/**
 * Generate TS proto bindings. Depends on the buf CLI. Returns a map of
 * relative paths to generated ts contents.
 * This is a generator function - it can be reentered to trigger cleanup logic.
 */
function* genProtoBindings(repoPath, outputPath, namespace) {
    const protoPath = getProtoPath(repoPath, namespace);
    if (!node_fs_1.default.existsSync(protoPath)) {
        yield {};
        return;
    }
    // Generate
    const bufGenTemplate = JSON.stringify({
        version: "v1",
        managed: { enabled: true },
        plugins: [
            {
                plugin: "buf.build/bufbuild/es:v1.7.2",
                out: "gen",
                opt: ["target=ts"],
            },
        ],
    });
    const cmd = (0, child_process_1.spawnSync)("buf", [
        "generate",
        "--template",
        bufGenTemplate,
        repoPath,
        "--path",
        protoPath,
        "--output",
        outputPath,
    ], {
        encoding: "utf-8",
    });
    if (cmd.error !== undefined || cmd.status !== 0) {
        throw new Error("Failed to generate proto bindings");
    }
    // Can stop here if not interested in contents
    yield {};
    // Yield the generated _pb.ts files' relative paths and contents
    const relGenPath = node_path_1.default.join("gen", namespace, "config", "v1beta1");
    const absGenPath = node_path_1.default.join(outputPath, relGenPath);
    const files = {};
    if (!node_fs_1.default.existsSync(absGenPath)) {
        yield files;
        return;
    }
    node_fs_1.default.readdirSync(absGenPath, {
        withFileTypes: true,
    }).forEach((dirEnt) => {
        if (dirEnt.isFile() && node_path_1.default.extname(dirEnt.name) === ".ts") {
            files[node_path_1.default.join(relGenPath, dirEnt.name)] = node_fs_1.default.readFileSync(node_path_1.default.join(absGenPath, dirEnt.name), {
                encoding: "utf-8",
            });
        }
    });
    yield files;
    // Clean up generated bindings
    // rimrafSync(outputPath);
}
exports.genProtoBindings = genProtoBindings;
//# sourceMappingURL=ts-to-lekko.js.map