"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.patchProgram = exports.patchCompilerHost = void 0;
const helpers_1 = require("./helpers");
function patch(target, methodName, patch) {
    const method = target[methodName];
    if (typeof method === "function") {
        const origMethod = method.bind(target);
        target[methodName] = ((...args) => 
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        patch(origMethod)(...args));
    }
}
function patchCompilerHost(host, sfCache) {
    patch(host, "getSourceFile", (origGetSourceFile) => (fileName, ...args) => {
        const cached = sfCache.get(fileName);
        if (cached !== undefined) {
            return cached;
        }
        return origGetSourceFile(fileName, ...args);
    });
}
exports.patchCompilerHost = patchCompilerHost;
function patchProgram(program) {
    patch(program, "getSemanticDiagnostics", (origGetSemanticDiagnostics) => (...args) => {
        const diagnostics = origGetSemanticDiagnostics(...args);
        // Ignore diagnostics on transformed Lekko TS files (e.g. Parameter 'client' implicitly has an 'any' type.)
        return diagnostics.filter((diagnostic) => {
            var _a, _b;
            return ((_a = diagnostic.file) === null || _a === void 0 ? void 0 : _a.fileName) === undefined ||
                !helpers_1.LEKKO_FILENAME_REGEX.test((_b = diagnostic.file) === null || _b === void 0 ? void 0 : _b.fileName);
        });
    });
}
exports.patchProgram = patchProgram;
//# sourceMappingURL=patch.js.map